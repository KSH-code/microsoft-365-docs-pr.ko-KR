---
title: 악용 방지 참고자료
keywords: 완화, 취약성, 완화, 악용, emet
description: 악용 방지 기능의 작동 방식에 대한 세부 Windows
ms.pagetype: security
ms.prod: m365-security
ms.mktglfcycl: manage
ms.sitesec: library
ms.localizationpriority: medium
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.date: 10/19/2021
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.technology: mde
ms.topic: article
ms.collection: m365-security-compliance
ms.openlocfilehash: d4bb0107c53c7fcbaee59d1db46d676fe407821b
ms.sourcegitcommit: e09ced3e3628bf2ccb84d205d9699483cbb4b3b0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/09/2021
ms.locfileid: "60884088"
---
# <a name="exploit-protection-reference"></a>Exploit Protection 참조

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


**적용 대상:**
- [엔드포인트용 Microsoft Defender](https://go.microsoft.com/fwlink/?linkid=2154037)
- [Microsoft 365 Defender](https://go.microsoft.com/fwlink/?linkid=2118804)

> 엔드포인트용 Microsoft Defender를 경험하고 싶으신가요? [무료 평가판을 신청하세요.](https://signup.microsoft.com/create-account/signup?products=7f379fee-c4f9-4278-b0a1-e4c8c2fcdf7e&ru=https://aka.ms/MDEp2OpenTrial?ocid=docs-wdatp-enablesiem-abovefoldlink)

Exploit Protection은 개발자가 소프트웨어를 컴파일하고 배포한 Pro IT 개발자가 적용할 수 있는 응용 프로그램에 대한 고급 보호 기능을 제공합니다.

이 문서는 Exploit Protection 정책을 성공적으로 빌드하고 적용하는 데 도움이 될 수 있도록 정책 수준과 개별 완화 수준에서 Exploit Protection이 작동하는 방법을 이해하는 데 도움이 됩니다.

## <a name="how-mitigations-are-applied"></a>완화가 적용되는 방법

Exploit Protection 완화는 응용 프로그램당 적용됩니다.

완화는 보호를 구성하는 각 프로그램에 대한 레지스트리 항목을 통해 구성됩니다. 이러한 설정은 각 프로그램에 대한 **MitigationOptions** 레지스트리 항목(**HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Image File Execution Options \ *ImageFileName* \ MitigationOptions )에** 저장됩니다. 프로그램을 다시 시작하고 프로그램을 변경하고 프로그램을 다시 시작할 때까지 유효하게 유지됩니다.

> [!IMPORTANT]
> 이미지 파일 실행 옵션을 사용하면 파일 이름이나 경로만 지정할 수 있으며 버전 번호, 아키텍처 또는 기타 차별화 기능은 지정할 수 없습니다. 고유한 이름 또는 경로가 있는 앱에 대한 완화를 대상으로 지정하여 해당 버전 및 응용 프로그램의 아키텍처를 테스트한 디바이스에만 적용해야 합니다.

PowerShell, 그룹 정책 또는 MDM을 통해 XML 구성 파일을 사용하여 exploit Protection 완화를 구성하는 경우 이 XML 구성 파일을 처리하는 경우 개별 레지스트리 설정이 자동으로 구성됩니다.

XML 파일을 배포하는 정책이 더 이상 적용되지 않는 경우 이 XML 구성 파일에 의해 배포된 설정은 자동으로 제거되지 않습니다. Exploit Protection 설정을 제거하려면 새로 Windows 10 또는 Windows 11 XML 구성을 내보내고 이 새 XML 파일을 배포합니다. 또는 Microsoft는 Exploit Protection 설정을 초기화하기 위한 Windows 보안 XML 파일을 제공합니다.

PowerShell을 사용하여 Exploit Protection 설정을 다시 설정하려면 다음 명령을 사용할 수 있습니다.

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
다음은 EP-reset.xml 기준과 함께 Windows 보안 예제입니다.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a>완화 참조

다음 섹션에서는 각 악용 방지 완화에서 제공하는 보호, 완화에 대한 호환성 고려 사항 및 사용 가능한 구성 옵션에 대해 자세히 설명합니다.

## <a name="arbitrary-code-guard"></a>임의 코드 보호

### <a name="description"></a>설명

임의 코드 보호는 악의적인 공격자가 메모리 안전 취약성을 통해 선택한 코드를 메모리에 로드하고 이 코드를 실행할 수 있는 것을 방지합니다.

임의 코드 보호는 응용 프로그램이 동적으로 생성된 코드(예: exe 자체 또는 dll에서 로드되지 않은 코드)를 실행하지 못하게 보호합니다. 임의의 코드 보호는 메모리가 실행 가능으로 표시되지 않도록 하여 작동합니다. 응용 프로그램이 메모리를 [할당하려고 할](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)때 보호 플래그를 검사합니다. 메모리는 읽기, 쓰기 및/또는 보호 플래그를 실행하여 할당할 수 있습니다. 할당에서 실행 보호 플래그를 [](/windows/win32/memory/memory-protection-constants) 포함하려고 시도하면 메모리 할당이 실패하고 오류 코드(STATUS_DYNAMIC_CODE_BLOCKED)가 반환됩니다. 마찬가지로 응용 프로그램에서 이미 할당된 메모리의 보호 플래그를 변경하려고 시도하고 [](/windows/win32/memory/memory-protection-constants) 실행 보호 플래그를 포함하면 권한 변경이 실패하고 오류 코드(STATUS_DYNAMIC_CODE_BLOCKED)가 반환됩니다. [](/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)

실행 플래그가  설정되지 않도록 설정하면 Windows 10 및 Windows 11 실행 명령 포인터가 해당 메모리로 설정되고 해당 코드를 실행하지 못하도록 보호할 수 있습니다.

### <a name="compatibility-considerations"></a>호환성 고려 사항

임의 코드 보호는 모든 메모리를 실행 가능으로 할당하지 못하게 하여 JIT(Just-in-Time) 컴파일러와 같은 접근 방식과의 호환성 문제를 제공합니다. 예를 들어 대부분의 최신 브라우저는 성능을 최적화하기 위해 JavaScript를 네이티브 코드로 컴파일합니다. 이러한 완화를 지원하려면 JIT 컴파일을 보호된 프로세스 외부로 이동하기 위해 재구성해야 합니다. 스크립트 또는 다른 중간 언어에서 코드를 동적으로 생성하는 다른 응용 프로그램은 이 완화와 유사하게 비호화됩니다.

### <a name="configuration-options"></a>구성 옵션

**스레드 옵트아웃** 허용 - 개별 스레드가 이 보호를 옵트아웃하도록 완화를 구성할 수 있습니다. 개발자는 이 완화에 대한 인식을 사용하여 응용 프로그램을 작성하고 이 스레드에서 동적 코드를 실행할 수 있도록 *ThreadInformation* 매개 변수를 **ThreadDynamicCodePolicy로** 설정하여 [**SetThreadInformation**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) API를 호출해야 합니다.

**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다. 그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Defender에서](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.

## <a name="block-low-integrity-images"></a>낮은 무결성 이미지 차단

### <a name="description"></a>설명

낮은 무결성 이미지를 차단하면 응용 프로그램이 일반적으로 샌드박스 브라우저에서 인터넷에서 다운로드한 것으로 인해 응용 프로그램에서 트러블되지 않은 파일을 로드할 수 없습니다.

이 완화는 이미지에 낮은 IL 프로세스에 대한 액세스 권한을 부여하고 신뢰 레이블 ACE가 없는 이미지에 ACE(액세스 제어 항목)가 있는 경우 이미지 로드를 차단합니다. 이 파일은 메모리 관리자가 구현하여 파일이 메모리에 매핑되지 못하게 차단합니다. 응용 프로그램이 낮은 무결성 이미지를 매핑하려고 하면 오류 STATUS_ACCESS_DENIED 트리거됩니다. 무결성 수준 작동 방식에 대한 자세한 내용은 필수 무결성 제어 [를 참조합니다.](/windows/win32/secauthz/mandatory-integrity-control)

### <a name="compatibility-considerations"></a>호환성 고려 사항

낮은 무결성 이미지를 차단하면 응용 프로그램이 인터넷에서 다운로드한 파일을 로드할 수 없습니다. 응용 프로그램 워크플로에서 다운로드된 이미지를 로드해야 하는 경우 신뢰도가 더 높은 프로세스에서 다운로드되거나 이러한 완화를 적용하기 위해 명시적으로 다시 지정되어 있는 것이 좋습니다.

### <a name="configuration-options"></a>구성 옵션

**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다. 그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.

## <a name="block-remote-images"></a>원격 이미지 차단

### <a name="description"></a>설명

원격 이미지를 차단하면 응용 프로그램이 UNC 공유와 같은 원격 디바이스에서 호스트되는 파일을 로드하지 못하게 할 수 있습니다. 원격 이미지를 차단하면 공격자가 제어하는 외부 장치에 있는 메모리에 이진이 로드되지 않습니다.

이 완화는 이미지가 원격 장치에 있는 것으로 판단되는 경우 이미지 로드를 차단합니다. 이 파일은 메모리 관리자가 구현하여 파일이 메모리에 매핑되지 못하게 차단합니다. 응용 프로그램이 원격 파일을 매핑하려고 하면 오류 STATUS_ACCESS_DENIED 트리거됩니다.

### <a name="compatibility-considerations"></a>호환성 고려 사항

원격 이미지를 차단하면 응용 프로그램이 원격 장치에서 이미지를 로드할 수 없습니다. 응용 프로그램이 원격 장치에서 파일 또는 플러그 인을 로드하는 경우 이 완화와 호환되지 않습니다.

### <a name="configuration-options"></a>구성 옵션

**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다. 그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.

## <a name="block-untrusted-fonts"></a>신뢰할 수 없는 글꼴 차단

### <a name="description"></a>설명

트러스터가 없는 글꼴을 차단하면 글꼴 구문 분석에 결함이 있을 위험이 완화되고 공격자가 디바이스에서 코드를 실행할 수 있습니다. Windows\fonts 디렉터리에 설치된 글꼴만 GDI에서 처리하기 위해 로드됩니다.

이 완화는 파일 위치의 유효성을 검사하는 GDI 내에서 구현됩니다. 파일이 시스템 글꼴 디렉터리에 없는 경우 글꼴이 구문 분석에 로드되지 않습니다. 이 경우 해당 호출이 실패합니다.

이 완화는 Windows 10 1607 이상에서 제공된 기본 제공 완화와 Windows 11 커널에서 사용자 모드 앱 컨테이너로 글꼴 구문 분석이 이동하는 기본 제공 완화와 함께 제공됩니다. 따라서 글꼴 구문 분석에 기반한 악용은 샌드박스가 있는 격리된 컨텍스트에서 발생하여 위험을 크게 줄일 수 있습니다. 이 완화에 대한 자세한 내용은 블로그 [Hardening Windows 10 악용 완화를 참조하세요.](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/)

### <a name="compatibility-considerations"></a>호환성 고려 사항

시스템 글꼴 디렉터리 외부에 있는 글꼴의 가장 일반적인 사용은 웹 [글꼴입니다.](/typography/fonts/font-faq#web) 최신 브라우저(예: Microsoft Edge GDI DirectWrite 대신 최신 브라우저를 사용하며 영향을 되지 않습니다. 그러나 Internet Explorer 11(및 새 Microsoft Edge의 IE 모드)과 같은 레거시 브라우저는 특히 글꼴 문자 모양을 사용하여 UI를 표시하는 Office 365 응용 프로그램에 영향을 줄 수 있습니다.

### <a name="configuration-options"></a>구성 옵션

**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다. 그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.

## <a name="code-integrity-guard"></a>코드 무결성 가드

### <a name="description"></a>설명

코드 무결성 보호는 프로세스에 로드된 모든 이진이 Microsoft에서 디지털 서명되도록 합니다. 코드 무결성 보호에는 [WHQL(Windows](/windows-hardware/drivers/install/whql-release-signature) 품질 랩) 서명이 포함되어 프로세스 내에서 WHQL 승인 드라이버를 실행할 수 있습니다.

이 완화는 메모리 관리자 내에서 구현됩니다. 이진 파일을 메모리에 매핑하지 못하게 차단합니다. Microsoft에서 서명하지 않은 이진 파일을 로드하려고 하면 메모리 관리에서 오류 메시지가 STATUS_INVALID_IMAGE_HASH. 메모리 관리자 수준에서 차단하면 프로세스에 의해 로드된 이진과 이진이 모두 프로세스에 주입되지 않습니다.

### <a name="compatibility-considerations"></a>호환성 고려 사항

이 완화는 Microsoft에서 서명하지 않은 이진 파일을 특별히 차단합니다. 따라서 소프트웨어가 해당 소프트웨어에 의해 배포(디지털 서명)된 경우와 Microsoft Store 서명된 이미지의 로드를 허용하는 옵션을 선택하지 않는 한 대부분의 타사 소프트웨어와 Microsoft Store 않습니다.

### <a name="configuration-options"></a>구성 옵션

**Microsoft Store** 서명된 이미지 로드 허용 - Microsoft Store 배포하는 응용 프로그램은 Microsoft Store 디지털 서명을 하게 며, 이 구성을 추가하면 저장소 인증 프로세스를 거쳤던 이진이 응용 프로그램에서 로드할 수 있습니다.

**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다. 그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.

## <a name="control-flow-guard-cfg"></a>CFG(제어 흐름 보호)

### <a name="description"></a>설명

CFG(제어 흐름 보호)는 간접 함수 호출을 보호하여 메모리 손상 취약성을 사용하는 공격자가 위험을 완화합니다. 예를 들어 공격자는 버퍼 오버플로 취약성을 사용하여 함수 포인터가 포함된 메모리를 덮어넣고 해당 함수 포인터를 선택한 실행 코드(프로그램에 삽입될 수도 있는)에 대한 포인터로 바꿀 수 있습니다.

이 완화는 컴파일 시 다른 검사를 삽입하여 제공됩니다. 각 간접 함수를 호출하기 전에 대상이 호출되기 전에 올바른 호출 대상이 올바른지 확인하는 다른 지침이 추가됩니다. 대상이 유효한 통화 대상이 아닌 경우 응용 프로그램이 종료됩니다. 따라서 CFG 지원으로 컴파일된 응용 프로그램만 이 완화를 통해 혜택을 받을 수 있습니다.

올바른 대상에 대한 검사는 해당 커널에서 Windows 합니다. 실행 파일이 로드되면 간접 통화 대상에 대한 메타데이터가 로드 시 추출되고 유효한 통화 대상으로 표시됩니다. 또한 메모리가 할당되고 생성된 코드와 같은 실행 가능으로 표시되면 이러한 메모리 위치도 유효한 호출 대상으로 표시되어 JIT 컴파일과 같은 메커니즘을 지원할 수 있습니다.

### <a name="compatibility-considerations"></a>호환성 고려 사항

CFG를 지원하기 위해 응용 프로그램을 컴파일해야 하기 때문에 응용 프로그램과의 호환성을 암시적으로 선언합니다. 따라서 대부분의 응용 프로그램은 이 완화 기능을 사용하도록 설정해야 합니다. 이러한 검사는 이진 파일로 컴파일되어 있기 때문에 적용할 수 있는 구성은 커널 내에서 확인을 사용하지 않도록 Windows 있습니다. 즉, 완화는 기본적으로 설정되어 있지만 나중에 응용 프로그램 개발자가 테스트에서 검색하지 못했다는 호환성 문제가 확인되면 항상 "예"를 반환하도록 Windows 커널을 구성할 수 있습니다.

### <a name="configuration-options"></a>구성 옵션

**엄격한 CFG** 사용 - 엄격한 모드에서 프로세스에 로드된 모든 이진은 로드하려면 Control Flow Guard에 대해 컴파일해야 합니다(또는 리소스 dll과 같은 실행 코드가 없는 경우).

> [!Note]
> **제어 흐름 보호에는** 감사 모드가 없습니다. 이 완화를 사용하도록 설정된 이진이 컴파일됩니다.

## <a name="data-execution-prevention-dep"></a>데이터 실행 방지(DEP)

### <a name="description"></a>설명

DEP(데이터 실행 방지)는 실행 가능으로 명시적으로 할당되지 않은 메모리가 실행되지 않도록 합니다. DEP는 버퍼 오버플로를 통해 악성 코드를 주입한 다음 해당 코드를 실행하는 공격자로부터 보호합니다.

명령 포인터를 실행 가능으로 표시되지 않은 메모리 주소로 설정하려고 하면 프로세서에서 예외(일반 보호 위반)를 발생하여 응용 프로그램이 중단됩니다.

### <a name="compatibility-considerations"></a>호환성 고려 사항

모든 x64, ARM 및 ARM-64 실행은 기본적으로 DEP를 사용하도록 설정되어 있으며 사용하지 않도록 설정할 수 없습니다. 응용 프로그램이 DEP 없이 실행된 적이 없는 것이기 때문에 호환성이 가정됩니다.

모든 x86(32비트) 이진은 기본적으로 DEP를 사용하도록 설정되어 있지만 프로세스당 DEP를 사용하지 않도록 설정할 수 있습니다. 일부 이전 레거시 응용 프로그램(일반적으로 XP SP2 이전에 Windows 응용 프로그램은 DEP와 호환되지 않을 수 있습니다. 이러한 응용 프로그램은 일반적으로 코드를 동적으로 생성하거나(예: JIT 컴파일) 또는 코드를 동적으로 생성하는 이전 버전의 ATL과 같은 이전 라이브러리에 연결합니다.

### <a name="configuration-options"></a>구성 옵션

**ATL Thunk 에뮬ation** 사용 - 이 구성 옵션은 ATL Thunk 에뮬ATION을 사용하지 않도록 설정합니다. 기본 ActiveX 라이브러리인 ATL은 최대한 작고 빠르게 설계됩니다. 이진 크기를 줄이기 위해 *스킹(thunking)이라는 기술을 사용합니다.* 번킹은 일반적으로 32비트 응용 프로그램과 16비트 응용 프로그램 간에 상호 작용하는 것으로 생각되지만 ATL에는 16비트 구성 요소가 없습니다. 대신 이진 크기에 최적화하기 위해 ATL은 단어 맞춤이 아닌 컴퓨터 코드를 메모리에 저장한 다음(더 작은 이진 파일을 생성) 해당 코드를 직접 호출합니다. Visual Studio 7.1 또는 이전 버전(Visual Studio 2003)으로 컴파일된 ATL 구성 요소는 이 메모리를 실행 가능으로 할당하지 않습니다. unk 에뮬ATION은 호환성 문제를 해결합니다. 이진 확장 모델(예: Internet Explorer 11)을 사용하는 응용 프로그램에는 ATL Thunk 에뮬션을 사용하도록 설정해야 하는 경우가 종종 있습니다.

## <a name="disable-extension-points"></a>확장 지점 사용 안 함

### <a name="description"></a>설명

이 완화는 응용 프로그램에 대한 다양한 확장 지점을 사용하지 않도록 설정하여 악의적인 콘텐츠의 지속성 설정 또는 권한 상승에 사용될 수 있습니다.

여기에는 다음이 포함됩니다.

- **AppInit DLL** - 프로세스가 시작될 때마다 시스템은 진입점 함수를 호출하기 전에 지정된 DLL을 새로 시작된 프로세스의 컨텍스트로 로드합니다. [AppInit DLS에 대한 자세한 내용은 에서 찾을 수 있습니다.](/windows/win32/winmsg/about-window-classes#application-global-classes) 이 완화를 적용하면 AppInit DL이 로드되지 않습니다. Windows 7부터는 여기에 설명된 바와 같이 AppInit DLS에 디지털 [서명이 필요합니다.](/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2) 또한 여기서 설명하는 Windows 8 AppInit DL은 SecureBoot을 사용하도록 설정한 경우 [로드되지 않습니다.](/windows/win32/dlls/secure-boot-and-appinit-dlls)
- **레거시** IME(입력기) - 사용자가 키보드에서 표시될 수 있는 것보다 많은 문자가 있는 언어로 텍스트를 입력할 수 있습니다. 타사에서 IM을 만들 수 있습니다. 악의적인 IME는 이 입력 캡처에서 자격 증명 또는 기타 중요한 정보를 얻을 수 있습니다. 레거시 IM이라고 하는 일부 IM은 UWP 앱이 Windows 데스크톱 앱에서만 작동됩니다. 또한 이 완화는 이 레거시 IME가 지정된 데스크톱 앱으로 Windows 방지합니다.
- **Windows 후크** - 응용 프로그램에서 [SetWinEventHook API를](/windows/win32/api/winuser/nf-winuser-setwineventhook) 호출하여 이벤트 발생 시 관심을 등록할 수 있습니다. DLL이 지정되어 프로세스에 삽입할 수 있습니다. 이 완화는 삽입된 DLL을 통해 In-process를 실행하는 대신 등록 프로세스에 후크를 강제로 게시합니다.

### <a name="compatibility-considerations"></a>호환성 고려 사항

이러한 확장 지점은 대부분 비교적 적게 사용되지 않습니다. 따라서 호환성에 미치는 영향은 일반적으로 작고 특히 개별 응용 프로그램 수준에서는 그렇습니다. 한 가지 고려 사항은 사용자가 보호된 응용 프로그램에서 작동하지 않는 타사 레거시 IM을 사용하는 경우입니다.

### <a name="configuration-options"></a>구성 옵션

이 완화를 위한 구성 옵션은 없습니다.

> [!Note]
> **확장점을 사용하지 않도록 설정하는** 경우 감사 모드가 없습니다.

## <a name="disable-win32k-system-calls"></a>Win32k 시스템 호출 사용 안 함

### <a name="description"></a>설명

Win32k.sys 공격자는 광범위한 공격 표면을 제공합니다. 커널 모드 구성 요소로 샌드박스가 적용된 응용 프로그램에 대한 이스케이프 벡터로 대상이 지정되는 경우도 잦습니다. 이 완화는 스레드가 자체적으로 GUI 스레드로 변환되지 않도록 차단하여 win32k.sys 호출을 방지합니다. 그런 다음 Win32k 함수를 호출할 수 있는 액세스 권한이 부여됩니다. 스레드는 만들 때 GUI가 아닌 것이지만 첫 번째 호출 시 또는 [IsGuiThread에](/windows/win32/api/winuser/nf-winuser-isguithread)win32k.sys API 호출을 통해 변환됩니다.

### <a name="compatibility-considerations"></a>호환성 고려 사항

이 완화는 전용 비 UI 프로세스인 프로세스에 대해 고안되었습니다. 예를 들어 대부분의 최신 브라우저는 프로세스의 고리와 비 UI 프로세스를 통합합니다. 단일 프로세스를 사용하여 GUI를 표시하는 응용 프로그램은 이 완화의 영향을 하게 됩니다.

### <a name="configuration-options"></a>구성 옵션

**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다. 그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.

## <a name="do-not-allow-child-processes"></a>자식 프로세스 허용 안 함

### <a name="description"></a>설명

이 완화를 통해 응용 프로그램에서 새 자식 응용 프로그램을 만들 수 없습니다. 악의적인 입력("육지에서 살기" 공격)을 사용하여 디바이스에서 신뢰할 수 있는 프로세스를 시작하는 데 사용되는 일반적인 기술은 종종 장치에서 다른 응용 프로그램을 실행해야 합니다. 응용 프로그램에서 자식 프로세스를 시작하게 하는 정당한 이유가 없는 경우 이러한 완화는 잠재적인 공격 벡터를 완화합니다. 이 완화는 오류 메시지가 표시되어 있는 자식 프로세스에 대한 토큰을 만드는 데 차단하는 프로세스 토큰에 속성을 설정하여 STATUS_CHILD_PROCESS_BLOCKED.

### <a name="compatibility-considerations"></a>호환성 고려 사항

응용 프로그램에서 브라우저 또는 외부 브라우저를 시작하거나 컴퓨터에서 다른 유틸리티를 실행하는 하이퍼링크 지원과 같은 이유로 자식 응용 프로그램을 시작하면 이 완화가 적용되어 이 기능이 손상됩니다.

### <a name="configuration-options"></a>구성 옵션

**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다. 그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.

## <a name="export-address-filtering"></a>주소 필터링 내보내기

### <a name="description"></a>설명

EAF(내보내기 주소 필터링)는 로드된 모든 모듈의 내보내기 주소 테이블을 확인하여 공격에 유용한 API가 포함된 모듈을 찾는 악성 코드의 위험을 완화합니다. 이는 셸 코드에서 사용되는 일반적인 전략입니다. 이러한 공격의 위험을 완화하기 위해 이 완화는 일반적으로 공격하는 세 가지 모듈을 보호합니다.

- ntdll.dll
- kernelbase.dll
- kernel32.dll

이 완화는 [export 디렉터리에서 내보내기 주소 테이블을 지점으로 하는 메모리 [페이지를 보호합니다.](/windows/win32/debug/pe-format#export-address-table) 이 메모리 페이지에는 PAGE_GUARD [보호가](/windows/win32/memory/creating-guard-pages) 적용됩니다. 누군가 이 메모리에 액세스하면 메모리가 STATUS_GUARD_PAGE_VIOLATION. 이 완화는 이 예외를 처리하며 액세스 명령이 유효성 검사를 통과하지 못하면 프로세스가 종료됩니다.

### <a name="compatibility-considerations"></a>호환성 고려 사항

이 완화는 주로 디버거, 샌드박스 응용 프로그램, DRM을 사용하는 응용 프로그램 또는 디버깅 방지 기술을 구현하는 응용 프로그램과 같은 응용 프로그램에 대한 문제입니다.

### <a name="configuration-options"></a>구성 옵션

**악용으로** 악용되는 모듈에 대한 액세스 유효성 검사 - EAF+라고도 하는 이 옵션은 일반적으로 공격하는 다른 모듈에 대한 보호 기능을 추가합니다.

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

또한 EAF+를 사용하도록 설정하여 이 완화는 셸코드가 메모리에서 잠재적으로 관심이 있는 모듈을 식별하기 위해 검색할 수 있는 알려진 메모리 콘텐츠의 또 다른 측면인 "MZ" 헤더인 "MZ" 헤더가 포함된 페이지에 PAGE_GUARD 보호를 추가합니다. [](/windows/win32/debug/pe-format#ms-dos-stub-image-only)

**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다. 그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.

## <a name="force-randomization-for-images-mandatory-aslr"></a>이미지에 대한 강제 임의 지정(필수 ASLR)

### <a name="description"></a>설명

ASLR(Address Space Layout Randomization)을 통해 공격자가 시스템의 메모리 레이아웃에 대한 지식을 사용하여 이미 프로세스 메모리에 있으며 실행 가능으로 표시된 코드를 실행할 위험을 완화합니다. 이렇게 하면 반송 공격자가 컨텍스트를 설정한 다음 반송 주소를 수정하여 적의 목적에 적합한 컨텍스트를 사용하여 기존 코드를 실행하도록 공격자가 위험을 완화할 수 있습니다.

필수 ASLR은 프로세스 내의 모든 DL을 강제로 다시베이스합니다. 개발자는 [/DYNAMICBASE](/cpp/build/reference/dynamicbase-use-address-space-layout-randomization) 링커 옵션을 사용하여 ASLR을 사용하도록 설정할 수 있으며 이 완화는 동일한 영향을 미치게 됩니다.

메모리 관리자가 이미지에서 프로세스로 매핑하는 경우 필수 ASLR은 ASLR에 옵트인하지 않은 DLL 및 EXES를 강제로 다시베이스합니다. 그러나 이 재지정은 인트로피가 없습니다. 따라서 메모리의 예측 가능한 위치에 배치할 수 있습니다. 이진의 재지정 및 임의 위치의 경우 이 완화는 임의로 메모리 할당(상하 [ASLR)과](#randomize-memory-allocations-bottom-up-aslr)쌍을 이루는 것이 좋습니다.

### <a name="compatibility-considerations"></a>호환성 고려 사항

ASLR의 이러한 호환성 영향은 일반적으로 이진 파일의 기본 주소에 대해 가정하거나 기본 재배치 정보를 제거한 컴파일러를 사용하여 만든 이전 응용 프로그램으로 제한됩니다. 이로 인해 실행 흐름이 메모리의 실제 위치가 아니라 예상한 위치로 이동하려고 할 때 예측할 수 없는 오류가 발생할 수 있습니다.

### <a name="configuration-options"></a>구성 옵션

**제거된** 이미지를 허용하지 않습니다. 이 옵션은 재배치 정보가 제거된 이미지의 로드를 차단합니다. Windows PE 파일 형식은 절대 주소를 포함하며, 컴파일러는 로더가 모든 상대 메모리 참조와 해당 오프셋을 찾는 데 사용할 수 있는 [기본 위치 변경 테이블]을 생성하여 이진 파일이 기본 기본 주소에서 로드되지 않는 경우 업데이트할 수 있습니다. 일부 이전 응용 프로그램은 프로덕션 빌드에서 이 정보를 제거하므로 이러한 이진은 다시 사용할 수 없습니다. 이 완화는 이러한 이진이 기본 기본 주소로 로드되는 것을 허용하는 대신 로드되지 못하게 차단합니다.

> [!Note]
> **이미지에 대한 임의 설정 강제(필수 ASLR)에는** 감사 모드가 없습니다.

## <a name="import-address-filtering-iaf"></a>주소 필터링 가져오기(IAF)

### <a name="description"></a>설명

IAF(가져오기 주소 필터링) 완화는 IAT(가져오기 주소 테이블)를 수정하여 해당 함수가 호출될 때 공격자가 선택한 임의의 코드로 리디렉션하도록 수정하여 응용 프로그램의 제어 흐름을 변경하는 공격자 위험을 완화하는 데 도움이 됩니다. 공격자는 이 방법을 사용하여 제어를 숨기거나 중요한 API에 대한 호출을 가로채고 검사하고 차단할 수 있습니다.

보호된 모든 API의 메모리 페이지에는 PAGE_GUARD [보호가](/windows/win32/memory/creating-guard-pages) 적용됩니다. 누군가 이 메모리에 액세스하면 메모리가 STATUS_GUARD_PAGE_VIOLATION. 이 완화는 이 예외를 처리하며 액세스 명령이 유효성 검사를 통과하지 못하면 프로세스가 종료됩니다.

이 완화는 다음과 같은 Windows 보호합니다.

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a>호환성 고려 사항

이러한 완화로 인해 API 가로채기를 수행하는 합법적인 응용 프로그램이 검색되고 일부 응용 프로그램이 중단될 수 있습니다. 보안 소프트웨어 및 응용 프로그램 호환성 shims를 예로 들 수 있습니다.

### <a name="configuration-options"></a>구성 옵션

**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다. 그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.

## <a name="randomize-memory-allocations-bottom-up-aslr"></a>임의로 메모리 할당(상하 ASLR)

### <a name="description"></a>설명

임의로 메모리 할당(상하 ASLR)을 수행하면 위치가 임의화 하므로 예측 가능하지 않습니다. 이 완화를 적용하려면 필수 ASLR이 필요합니다.

32비트 주소 공간의 크기는 추가할 수 있는 entropy에 실질적인 제약 조건을 적용하므로 64비트 응용 프로그램을 사용하는 경우 공격자가 메모리의 위치를 추측하기가 더 어려워질 수 있습니다.

### <a name="compatibility-considerations"></a>호환성 고려 사항

필수 ASLR(보스)과 호환되는 대부분의 응용 프로그램은 상한 ASLR의 다른 항목과도 호환됩니다. 일부 응용 프로그램은 로컬 포인터를 32비트 변수(기본 주소가 4GB 미만으로 예상)에 저장하는 경우 포인터 잘라 내기 문제가 있을 수 있으며, 따라서 사용하지 않도록 설정할 수 있는 높은 엔트로피 옵션과는 무관합니다.

### <a name="configuration-options"></a>구성 옵션

**높은 entropy를** 사용하지 않도록 설정 - 이 옵션은 64비트 응용 프로그램에 대한 상한 할당에 24비트(1 TB의 분배)를 추가하는 높은 entropy ASLR 사용을 사용하지 않도록 합니다.

> [!Note]
> **임의로 메모리 할당(상하 ASLR)에는** 감사 모드가 없습니다.

## <a name="simulate-execution-simexec"></a>실행 시뮬레이션(SimExec)

### <a name="description"></a>설명

시뮬레이트 실행(SimExec)은 32비트 응용 프로그램에만 해당합니다. 이렇게 하면 중요한 API에 대한 호출이 합법적인 호출자 기능으로 돌아가는지 검사하는 데 도움이 됩니다. 이 작업에서는 중요한 API에 대한 호출을 가로채고 호출자에게 돌아가야 하는 RET 명령을 찾는 인코딩된 어셈블리 언어 지침을 따라 실행을 시뮬레이션합니다. 그런 다음 해당 함수를 검사하고 메모리에서 뒤로를 따라 앞의 CALL 명령을 찾아 함수와 CALL 명령이 일치하는지 여부와 RET이 가로채지 않은지 여부를 파악합니다.

이 완화로 가로채진 API는 다음입니다.

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

ROP 가제트가 감지되면 프로세스가 종료됩니다.

### <a name="compatibility-considerations"></a>호환성 고려 사항

API 가로채기(특히 보안 소프트웨어)를 수행하는 응용 프로그램은 이 완화로 호환성 문제를 일으킬 수 있습니다.

이 완화는 임의 Code Guard 완화와는 무관합니다.

### <a name="configuration-options"></a>구성 옵션

**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다. 그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.

## <a name="validate-api-invocation-callercheck"></a>API 호출 확인(CallerCheck)

### <a name="description"></a>설명

API 호출 유효성 검사(CallerCheck)는 유효한 호출자로부터 중요한 API가 호출된 것이 유효한지 검사하는 ROP(반환 지향 프로그래밍) 기술에 대한 완화입니다. 이 완화는 전달된 반환 주소를 검사한 다음 역으로 분해하여 반환 주소 위에 있는 호출을 찾아 호출 대상이 함수로 전달된 매개 변수와 일치하는지 여부를 판단합니다.

이 완화로 가로채진 API는 다음입니다.

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

ROP 가제트가 감지되면 프로세스가 종료됩니다.

### <a name="compatibility-considerations"></a>호환성 고려 사항

API 가로채기(특히 보안 소프트웨어)를 수행하는 응용 프로그램은 이 완화로 호환성 문제를 일으킬 수 있습니다.

이 완화는 임의 Code Guard 완화와는 무관합니다.

### <a name="configuration-options"></a>구성 옵션

**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다. 그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.

## <a name="validate-exception-chains-sehop"></a>예외 체인 확인(SEHOP)

### <a name="description"></a>설명

SEHOP(예외 체인 유효성 검사)는 *SEH(구조적* 예외 처리기) 덮어 사용 기술에 대한 완화입니다. [구조화된 예외 처리는](/windows/win32/debug/structured-exception-handling) 응용 프로그램에서 특정 예외를 처리하기 위해 요청하는 프로세스입니다. 예외 처리기도 함께 연결됩니다. 따라서 한 예외 처리기에서 특정 예외를 처리하지 않을 경우 처리하기로 결정하기 전까지는 체인의 다음 예외 처리기로 예외 처리기에 전달될 수 있습니다. 처리기 목록은 동적이기 때문에 스택에 저장됩니다. 공격자는 스택 오버플로 취약성을 사용하여 예외 처리기에서 공격자가 선택한 코드에 대한 포인터를 덮어 사용할 수 있습니다.

이 완화는 SEH 디자인에 따라 각 SEH 항목에 예외 처리기에 대한 포인터와 예외 체인의 다음 처리기 포인터가 모두 포함되어 있습니다. 이 완화는 예외가 호출된 경우 SEH 체인의 유효성을 검사하는 예외 디스패치에 의해 호출됩니다. 다음을 검증합니다.

- 모든 예외 체인 레코드가 스택 경계 내에 있습니다.
- 모든 예외 레코드가 정렬됩니다.
- 예외 처리기 포인터가 스택을 포인트하지 않습니다.
- 뒤로 포인터가 없음
- 예외 체인은 알려진 최종 예외 처리기에서 종료됩니다.

이러한 유효성 검사가 실패하면 예외 처리가 중단됩니다. 예외는 처리되지 않습니다.

### <a name="compatibility-considerations"></a>호환성 고려 사항

SEHOP와의 호환성 문제는 비교적 드물게 있습니다. 응용 프로그램에서 예외 체인 손상에 종속되는 경우는 끊이지 않습니다. 그러나 일부 응용 프로그램은 타이밍이 미묘하게 변경되어 응용 프로그램에서 잠정 다중 스레딩 버그를 표시하는 경선 조건으로 나타날 수 있습니다.

### <a name="configuration-options"></a>구성 옵션

> [!Note]
> **SEHOP(예외 체인)에 감사** 모드가 없는지 검사합니다.

## <a name="validate-handle-usage"></a>핸들 사용 확인

### <a name="description"></a>설명

*핸들 사용 유효성* 검사는 기존 핸들을 사용하여 보호된 개체에 액세스하는 공격자로부터 보호하는 완화입니다. [핸들은](/windows/win32/sysinfo/handles-and-objects) 보호된 개체에 대한 참조입니다. 응용 프로그램 코드가 잘못된 핸들을 참조하는 경우 해당 코드가 이전에 기록한 핸들을 사용하려고 시도하고 있지만 인식하지 못하게 될 응용 프로그램 참조 계산을 나타낼 수 있습니다. 응용 프로그램에서 단순히 null을 반환하는 대신 잘못된 개체를 사용하려고 하면 응용 프로그램에서 예외를 발생(STATUS_INVALID_HANDLE.

이 완화는 스토어 응용 프로그램에 Windows 자동으로 적용됩니다.

### <a name="compatibility-considerations"></a>호환성 고려 사항

핸들 참조를 정확하게 추적하지 못하고 예외 처리기에서 이러한 작업을 래핑하지 않은 응용 프로그램은 잠재적으로 이 완화의 영향을 을 수 있습니다.

### <a name="configuration-options"></a>구성 옵션

> [!Note]
> **핸들 사용의 유효성 검사에는** 감사 모드가 없습니다.

## <a name="validate-heap-integrity"></a>힙 무결성 확인

### <a name="description"></a>설명

유효성 *검사* 힙 무결성 완화는 힙 손상이 감지되면 응용 프로그램이 종료되는 Windows 힙 완화의 보호 수준을 높입니다. 완화에는 다음이 포함됩니다.

- HEAP 핸들이 비우지 못하게 방지
- 힙 할당을 위해 확장된 블록 헤더에 대해 다른 유효성 검사 수행
- 힙 할당이 아직 사용 중으로 플래그가 지정되지 않은지 확인
- 최소 크기 이상의 큰 할당, 힙 세그먼트 및 하위 그룹에 보호 페이지 추가

### <a name="compatibility-considerations"></a>호환성 고려 사항

이 완화는 64비트 응용 프로그램 및 Vista 이상을 대상으로 하는 32비트 응용 프로그램에 Windows 이미 적용됩니다. XP 또는 Windows 이전 버전의 레거시 응용 프로그램은 거의 사용되지는 않습니다.

### <a name="configuration-options"></a>구성 옵션

> [!Note]
> **힙 무결성에 감사** 모드가 없는지 검사합니다.

## <a name="validate-image-dependency-integrity"></a>이미지 종속성 무결성 확인

### <a name="description"></a>설명

이미지 *종속성* 유효성 검사 완화는 이진으로 정적으로 연결된 dll에 대한 코드를 대체하려는 공격으로부터 Windows 데 도움이 됩니다. DLL 심기 기술은 악의적인 코드를 주입하는 로더의 검색 메커니즘을 남용합니다. 악성 코드를 높은 컨텍스트에서 실행하는 데 사용할 수 있습니다. 로더가 Windows 이진 파일을 로드한 다음 이진이 사용하는 모든 dll을 로드하면 이러한 이진 파일도 디지털 서명된 바이너리로 Windows 확인됩니다. 서명 검사에 실패하면 dll이 로드되지 않는 것이고 예외가 발생하여 예외가 STATUS_INVALID_IMAGE_HASH.

### <a name="compatibility-considerations"></a>호환성 고려 사항

호환성 문제는 확연한 일입니다. Windows 이진을 로컬 전용 버전으로 바꾸는 데 의존하는 응용 프로그램에는 영향을 주며 다중 스레드 응용 프로그램에서 미묘한 타이밍 버그가 노출될 위험이 있습니다.

### <a name="configuration-options"></a>구성 옵션

**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다. 그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.

## <a name="validate-stack-integrity-stackpivot"></a>스택 무결성 확인(StackPivot)

### <a name="description"></a>설명

스택 무결성 유효성 *검사(StackPivot)* 완화는 공격자가 힙 메모리에 위조 스택을 만든 다음 실행 흐름을 제어하는 위조 스택으로 응용 프로그램을 속이는 ROP 공격인 스택 피벗 공격으로부터 보호하는 데 도움이 됩니다.

이 완화는 많은 Windows API를 가로채고 스택 포인터 값을 검사합니다. 스택 포인터의 주소가 스택의 아래쪽과 위쪽 사이에 있지 않은 경우 이벤트가 기록되고 감사 모드가 아닌 경우 프로세스가 종료됩니다.

이 완화로 가로채진 API는 다음입니다.

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a>호환성 고려 사항

가짜 스택을 사용하는 응용 프로그램에는 영향을 주며 다중 스레드 응용 프로그램에서 미묘한 타이밍 버그가 노출될 위험이 있습니다.
API 가로채기(특히 보안 소프트웨어)를 수행하는 응용 프로그램은 이 완화로 호환성 문제를 일으킬 수 있습니다.

이 완화는 임의 Code Guard 완화와는 무관합니다.

### <a name="configuration-options"></a>구성 옵션

**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다. 그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.
