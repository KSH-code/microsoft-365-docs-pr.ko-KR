---
title: 악용 방지 참고자료
keywords: 완화, 취약성, 완화, 악용, emet
description: 악용 방지 기능의 작동 방식에 대한 세부 Windows 10
search.product: eADQiWindows 10XVcnh
ms.pagetype: security
ms.prod: m365-security
ms.mktglfcycl: manage
ms.sitesec: library
localization_priority: Normal
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.date: 01/06/2021
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.technology: mde
ms.topic: article
ms.openlocfilehash: b8d1abcc7f204b2d393729bc63b7b2b3ab53fbbd
ms.sourcegitcommit: 4886457c0d4248407bddec56425dba50bb60d9c4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/03/2021
ms.locfileid: "53290188"
---
# <a name="exploit-protection-reference"></a><span data-ttu-id="83fdd-104">Exploit Protection 참조</span><span class="sxs-lookup"><span data-stu-id="83fdd-104">Exploit Protection Reference</span></span>

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


<span data-ttu-id="83fdd-105">**적용 대상:**</span><span class="sxs-lookup"><span data-stu-id="83fdd-105">**Applies to:**</span></span>
- [<span data-ttu-id="83fdd-106">엔드포인트용 Microsoft Defender</span><span class="sxs-lookup"><span data-stu-id="83fdd-106">Microsoft Defender for Endpoint</span></span>](https://go.microsoft.com/fwlink/?linkid=2154037)
- [<span data-ttu-id="83fdd-107">Microsoft 365 Defender</span><span class="sxs-lookup"><span data-stu-id="83fdd-107">Microsoft 365 Defender</span></span>](https://go.microsoft.com/fwlink/?linkid=2118804)

><span data-ttu-id="83fdd-108">끝점용 Microsoft Defender를 경험하고 싶나요?</span><span class="sxs-lookup"><span data-stu-id="83fdd-108">Want to experience Microsoft Defender for Endpoint?</span></span> [<span data-ttu-id="83fdd-109">무료 평가판에 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-109">Sign up for a free trial.</span></span>](https://www.microsoft.com/microsoft-365/windows/microsoft-defender-atp?ocid=docs-wdatp-enablesiem-abovefoldlink)

<span data-ttu-id="83fdd-110">Exploit Protection은 개발자가 소프트웨어를 컴파일하고 배포한 Pro IT 개발자가 적용할 수 있는 응용 프로그램에 대한 고급 보호 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-110">Exploit protection provides advanced protections for applications that the IT Pro can apply after the developer has compiled and distributed the software.</span></span>

<span data-ttu-id="83fdd-111">이 문서는 Exploit Protection 정책을 성공적으로 빌드하고 적용하는 데 도움이 될 수 있도록 정책 수준과 개별 완화 수준에서 Exploit Protection이 작동하는 방법을 이해하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-111">This article helps you understand how exploit protection works, both at the policy level and at the individual mitigation level, to help you successfully build and apply Exploit Protection policies.</span></span>

## <a name="how-mitigations-are-applied"></a><span data-ttu-id="83fdd-112">완화가 적용되는 방법</span><span class="sxs-lookup"><span data-stu-id="83fdd-112">How mitigations are applied</span></span>

<span data-ttu-id="83fdd-113">Exploit Protection 완화는 응용 프로그램당 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-113">Exploit Protection mitigations are applied per application.</span></span>

<span data-ttu-id="83fdd-114">완화는 보호를 구성하는 각 프로그램에 대한 레지스트리 항목을 통해 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-114">Mitigations are configured via a registry entry for each program that you configure protections for.</span></span> <span data-ttu-id="83fdd-115">이러한 설정은 각 프로그램에 대한 **MitigationOptions** 레지스트리 항목(**HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Image File Execution Options \ *ImageFileName* \ MitigationOptions )에** 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-115">These settings are stored in the **MitigationOptions** registry entry for each program (**HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Image File Execution Options \ *ImageFileName* \ MitigationOptions**).</span></span> <span data-ttu-id="83fdd-116">프로그램을 다시 시작하고 프로그램을 변경하고 프로그램을 다시 시작할 때까지 유효하게 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-116">They take effect when you restart the program and remain effective until you change them and restart the program again.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="83fdd-117">이미지 파일 실행 옵션을 사용하면 파일 이름이나 경로만 지정할 수 있으며 버전 번호, 아키텍처 또는 기타 차별화 기능은 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-117">Image File Execution Options only allows you to specify a file name or path, and not a version number, architecture, or any other differentiator.</span></span> <span data-ttu-id="83fdd-118">고유한 이름 또는 경로가 있는 앱에 대한 완화를 대상으로 지정하여 해당 버전 및 응용 프로그램의 아키텍처를 테스트한 디바이스에만 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-118">Be careful to target mitigations to apps which have unique names or paths, applying them only on devices where you have tested that version and that architecture of the application.</span></span>

<span data-ttu-id="83fdd-119">PowerShell, 그룹 정책 또는 MDM을 통해 XML 구성 파일을 사용하여 exploit Protection 완화를 구성하는 경우 이 XML 구성 파일을 처리하는 경우 개별 레지스트리 설정이 자동으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-119">If you configure exploit protection mitigations using an XML configuration file, either via PowerShell, Group Policy, or MDM, when processing this XML configuration file, individual registry settings will be configured for you.</span></span>

<span data-ttu-id="83fdd-120">XML 파일을 배포하는 정책이 더 이상 적용되지 않는 경우 이 XML 구성 파일에 의해 배포된 설정은 자동으로 제거되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-120">When the policy distributing the XML file is no longer enforced, settings deployed by this XML configuration file will not be automatically removed.</span></span> <span data-ttu-id="83fdd-121">Exploit Protection 설정을 제거하려면 새로 설치한 장치에서 XML Windows 10 내보내고 이 새 XML 파일을 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-121">To remove Exploit Protection settings, export the XML configuration from a clean Windows 10 device, and deploy this new XML file.</span></span> <span data-ttu-id="83fdd-122">또는 Microsoft는 Exploit Protection 설정을 초기화하기 위한 Windows 보안 XML 파일을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-122">Alternately, Microsoft provides an XML file as part of the Windows Security Baselines for resetting Exploit Protection settings.</span></span>

<span data-ttu-id="83fdd-123">PowerShell을 사용하여 Exploit Protection 설정을 다시 설정하려면 다음 명령을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-123">To reset exploit protection settings using PowerShell, you could use the following command:</span></span>

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
<span data-ttu-id="83fdd-124">다음은 EP-reset.xml 기준과 함께 Windows 보안 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-124">Following is the EP-reset.xml distributed with the Windows Security Baselines:</span></span>
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a><span data-ttu-id="83fdd-125">완화 참조</span><span class="sxs-lookup"><span data-stu-id="83fdd-125">Mitigation Reference</span></span>

<span data-ttu-id="83fdd-126">다음 섹션에서는 각 악용 방지 완화에서 제공하는 보호, 완화에 대한 호환성 고려 사항 및 사용 가능한 구성 옵션에 대해 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-126">The following sections detail the protections provided by each exploit protection mitigation, the compatibility considerations for the mitigation, and the configuration options available.</span></span>

## <a name="arbitrary-code-guard"></a><span data-ttu-id="83fdd-127">임의 코드 보호</span><span class="sxs-lookup"><span data-stu-id="83fdd-127">Arbitrary code guard</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-128">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-128">Description</span></span>

<span data-ttu-id="83fdd-129">임의 코드 보호는 악의적인 공격자가 메모리 안전 취약성을 통해 선택한 코드를 메모리에 로드하고 이 코드를 실행할 수 있는 것을 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-129">Arbitrary code guard helps protect against a malicious attacker loading the code of their choice into memory through a memory safety vulnerability and being able to execute that code.</span></span>

<span data-ttu-id="83fdd-130">임의 코드 보호는 응용 프로그램이 동적으로 생성된 코드(예: exe 자체 또는 dll에서 로드되지 않은 코드)를 실행하지 못하게 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-130">Arbitrary code guard protects an application from executing dynamically generated code (code that is not loaded, for example, from the exe itself or a dll).</span></span> <span data-ttu-id="83fdd-131">임의의 코드 보호는 메모리가 실행 가능으로 표시되지 않도록 하여 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-131">Arbitrary code guard works by preventing memory from being marked as executable.</span></span> <span data-ttu-id="83fdd-132">응용 프로그램이 메모리를 [할당하려고 할](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)때 보호 플래그를 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-132">When an application attempts to [allocate memory](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc), we check the protection flags.</span></span> <span data-ttu-id="83fdd-133">메모리는 읽기, 쓰기 및/또는 보호 플래그를 실행하여 할당할 수 있습니다. 할당에서 실행 보호 플래그를 [](/windows/win32/memory/memory-protection-constants) 포함하려고 시도하면 메모리 할당이 실패하고 오류 코드(STATUS_DYNAMIC_CODE_BLOCKED)가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-133">(Memory can be allocated with read, write, and/or execute protection flags.) If the allocation attempts to include the [*execute*](/windows/win32/memory/memory-protection-constants) protection flag, then the memory allocation fails and returns an error code (STATUS_DYNAMIC_CODE_BLOCKED).</span></span> <span data-ttu-id="83fdd-134">마찬가지로 응용 프로그램에서 이미 할당된 메모리의 보호 플래그를 변경하려고 시도하고 [](/windows/win32/memory/memory-protection-constants) 실행 보호 플래그를 포함하면 권한 변경이 실패하고 오류 코드(STATUS_DYNAMIC_CODE_BLOCKED)가 반환됩니다. [](/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)</span><span class="sxs-lookup"><span data-stu-id="83fdd-134">Similarly, if an application attempts to [change the protection flags of memory](/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) that has already been allocated and includes the [*execute*](/windows/win32/memory/memory-protection-constants) protection flag, then the permission change fails and returns an error code (STATUS_DYNAMIC_CODE_BLOCKED).</span></span>

<span data-ttu-id="83fdd-135">실행 플래그가  설정되지 않도록 설정하면 Windows 10 명령 포인터가 해당 메모리로 설정되고 해당 코드를 실행하지 못하도록 보호할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-135">By preventing the *execute* flag from being set, the data execution prevention feature of Windows 10 can then protect against the instruction pointer being set to that memory and running that code.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-136">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-136">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-137">임의 코드 보호는 모든 메모리를 실행 가능으로 할당하지 못하게 하여 JIT(Just-in-Time) 컴파일러와 같은 접근 방식과의 호환성 문제를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-137">Arbitrary code guard prevents allocating any memory as executable, which presents a compatibility issue with approaches such as Just-in-Time (JIT) compilers.</span></span> <span data-ttu-id="83fdd-138">예를 들어 대부분의 최신 브라우저는 성능을 최적화하기 위해 JavaScript를 네이티브 코드로 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-138">Most modern browsers, for example, will compile JavaScript into native code in order to optimize performance.</span></span> <span data-ttu-id="83fdd-139">이러한 완화를 지원하려면 JIT 컴파일을 보호된 프로세스 외부로 이동하기 위해 재구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-139">In order to support this mitigation, they will need to be rearchitected to move the JIT compilation outside of the protected process.</span></span> <span data-ttu-id="83fdd-140">스크립트 또는 다른 중간 언어에서 코드를 동적으로 생성하는 다른 응용 프로그램은 이 완화와 유사하게 비호화됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-140">Other applications whose design dynamically generates code from scripts or other intermediate languages will be similarly incompatible with this mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-141">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-141">Configuration options</span></span>

<span data-ttu-id="83fdd-142">**스레드 옵트아웃** 허용 - 개별 스레드가 이 보호를 옵트아웃하도록 완화를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-142">**Allow thread opt-out** - You can configure the mitigation to allow an individual thread to opt-out of this protection.</span></span> <span data-ttu-id="83fdd-143">개발자는 이 완화에 대한 인식을 사용하여 응용 프로그램을 작성하고 이 스레드에서 동적 코드를 실행할 수 있도록 *ThreadInformation* 매개 변수를 **ThreadDynamicCodePolicy로** 설정하여 [**SetThreadInformation**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) API를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-143">The developer must have written the application with awareness of this mitigation, and have called the [**SetThreadInformation**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) API with the *ThreadInformation* parameter set to **ThreadDynamicCodePolicy** in order to be allowed to execute dynamic code on this thread.</span></span>

<span data-ttu-id="83fdd-144">**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-144">**Audit only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="83fdd-145">그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Defender에서](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-145">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="block-low-integrity-images"></a><span data-ttu-id="83fdd-146">낮은 무결성 이미지 차단</span><span class="sxs-lookup"><span data-stu-id="83fdd-146">Block low integrity images</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-147">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-147">Description</span></span>

<span data-ttu-id="83fdd-148">낮은 무결성 이미지를 차단하면 응용 프로그램이 일반적으로 샌드박스 브라우저에서 인터넷에서 다운로드한 것으로 인해 응용 프로그램에서 트러블되지 않은 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-148">Block low integrity images prevents the application from loading files that are untrusted, typically because they have been downloaded from the internet from a sandboxed browser.</span></span>

<span data-ttu-id="83fdd-149">이 완화는 이미지에 낮은 IL 프로세스에 대한 액세스 권한을 부여하고 신뢰 레이블 ACE가 없는 이미지에 ACE(액세스 제어 항목)가 있는 경우 이미지 로드를 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-149">This mitigation will block image loads if the image has an Access Control Entry (ACE) which grants access to Low IL processes and which does not have a trust label ACE.</span></span> <span data-ttu-id="83fdd-150">이 파일은 메모리 관리자가 구현하여 파일이 메모리에 매핑되지 못하게 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-150">It is implemented by the memory manager, which blocks the file from being mapped into memory.</span></span> <span data-ttu-id="83fdd-151">응용 프로그램이 낮은 무결성 이미지를 매핑하려고 하면 오류 STATUS_ACCESS_DENIED 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-151">If an application attempts to map a low integrity image, it will trigger a STATUS_ACCESS_DENIED error.</span></span> <span data-ttu-id="83fdd-152">무결성 수준 작동 방식에 대한 자세한 내용은 필수 무결성 제어 [를 참조합니다.](/windows/win32/secauthz/mandatory-integrity-control)</span><span class="sxs-lookup"><span data-stu-id="83fdd-152">For details on how integrity levels work, see [Mandatory Integrity Control](/windows/win32/secauthz/mandatory-integrity-control).</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-153">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-153">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-154">낮은 무결성 이미지를 차단하면 응용 프로그램이 인터넷에서 다운로드한 파일을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-154">Block low integrity images will prevent the application from loading files that were downloaded from the internet.</span></span> <span data-ttu-id="83fdd-155">응용 프로그램 워크플로에서 다운로드된 이미지를 로드해야 하는 경우 신뢰도가 더 높은 프로세스에서 다운로드되거나 이러한 완화를 적용하기 위해 명시적으로 다시 지정되어 있는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-155">If your application workflow requires loading images that are downloaded, you will want to ensure that they are downloaded from a higher-trust process, or are explicitly relabeled in order to apply this mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-156">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-156">Configuration options</span></span>

<span data-ttu-id="83fdd-157">**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-157">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="83fdd-158">그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-158">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="block-remote-images"></a><span data-ttu-id="83fdd-159">원격 이미지 차단</span><span class="sxs-lookup"><span data-stu-id="83fdd-159">Block remote images</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-160">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-160">Description</span></span>

<span data-ttu-id="83fdd-161">원격 이미지를 차단하면 응용 프로그램이 UNC 공유와 같은 원격 디바이스에서 호스트되는 파일을 로드하지 못하게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-161">Blocking remote images helps to prevent the application from loading files that are hosted on a remote device, such as a UNC share.</span></span> <span data-ttu-id="83fdd-162">원격 이미지를 차단하면 공격자가 제어하는 외부 장치에 있는 메모리에 이진이 로드되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-162">Blocking remote images helps protect against loading binaries into memory that are on an external device controlled by the attacker.</span></span>

<span data-ttu-id="83fdd-163">이 완화는 이미지가 원격 장치에 있는 것으로 판단되는 경우 이미지 로드를 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-163">This mitigation will block image loads if the image is determined to be on a remote device.</span></span> <span data-ttu-id="83fdd-164">이 파일은 메모리 관리자가 구현하여 파일이 메모리에 매핑되지 못하게 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-164">It is implemented by the memory manager, which blocks the file from being mapped into memory.</span></span> <span data-ttu-id="83fdd-165">응용 프로그램이 원격 파일을 매핑하려고 하면 오류 STATUS_ACCESS_DENIED 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-165">If an application attempts to map a remote file, it will trigger a STATUS_ACCESS_DENIED error.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-166">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-166">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-167">원격 이미지를 차단하면 응용 프로그램이 원격 장치에서 이미지를 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-167">Block remote images will prevent the application from loading images from remote devices.</span></span> <span data-ttu-id="83fdd-168">응용 프로그램이 원격 장치에서 파일 또는 플러그 인을 로드하는 경우 이 완화와 호환되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-168">If your application loads files or plug-ins from remote devices, then it will not be compatible with this mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-169">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-169">Configuration options</span></span>

<span data-ttu-id="83fdd-170">**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-170">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="83fdd-171">그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-171">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="block-untrusted-fonts"></a><span data-ttu-id="83fdd-172">신뢰할 수 없는 글꼴 차단</span><span class="sxs-lookup"><span data-stu-id="83fdd-172">Block untrusted fonts</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-173">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-173">Description</span></span>

<span data-ttu-id="83fdd-174">트러스터가 없는 글꼴을 차단하면 글꼴 구문 분석에 결함이 있을 위험이 완화되고 공격자가 디바이스에서 코드를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-174">Block untrusted fonts mitigates the risk of a flaw in font parsing leading to the attacker being able to run code on the device.</span></span> <span data-ttu-id="83fdd-175">Windows\fonts 디렉터리에 설치된 글꼴만 GDI에서 처리하기 위해 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-175">Only fonts that are installed into the windows\fonts directory will be loaded for processing by GDI.</span></span>

<span data-ttu-id="83fdd-176">이 완화는 파일 위치의 유효성을 검사하는 GDI 내에서 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-176">This mitigation is implemented within GDI, which validates the location of the file.</span></span> <span data-ttu-id="83fdd-177">파일이 시스템 글꼴 디렉터리에 없는 경우 글꼴이 구문 분석에 로드되지 않습니다. 이 경우 해당 호출이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-177">If the file is not in the system fonts directory, the font will not be loaded for parsing and that call will fail.</span></span>

<span data-ttu-id="83fdd-178">이 완화는 Windows 10 1607 이상에서 제공된 기본 제공 완화와 함께 커널에서 사용자 모드 앱 컨테이너로 글꼴 구문 분석이 이동됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-178">This mitigation is in addition to the built-in mitigation provided in Windows 10 1607 and later, which moves font parsing out of the kernel and into a user-mode app container.</span></span> <span data-ttu-id="83fdd-179">따라서 글꼴 구문 분석에 기반한 악용은 샌드박스가 있는 격리된 컨텍스트에서 발생하여 위험을 크게 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-179">Any exploit based on font parsing, as a result, happens in a sandboxed and isolated context, which reduces the risk significantly.</span></span> <span data-ttu-id="83fdd-180">이 완화에 대한 자세한 내용은 블로그 [Hardening Windows 10 악용 완화를 참조하세요.](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/)</span><span class="sxs-lookup"><span data-stu-id="83fdd-180">For details on this mitigation, see the blog [Hardening Windows 10 with zero-day exploit mitigations](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/).</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-181">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-181">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-182">시스템 글꼴 디렉터리 외부에 있는 글꼴의 가장 일반적인 사용은 웹 [글꼴입니다.](/typography/fonts/font-faq#web)</span><span class="sxs-lookup"><span data-stu-id="83fdd-182">The most common use of fonts outside of the system fonts directory is with [web fonts](/typography/fonts/font-faq#web).</span></span> <span data-ttu-id="83fdd-183">최신 브라우저(예: Microsoft Edge GDI DirectWrite 대신 최신 브라우저를 사용하며 영향을 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-183">Modern browsers, such as Microsoft Edge, use DirectWrite instead of GDI, and are not impacted.</span></span> <span data-ttu-id="83fdd-184">그러나 Internet Explorer 11(및 새 Microsoft Edge의 IE 모드)과 같은 레거시 브라우저는 특히 글꼴 문자 모양을 사용하여 UI를 표시하는 Office 365 응용 프로그램에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-184">However, legacy browsers, such as Internet Explorer 11 (and IE mode in the new Microsoft Edge) can be impacted, particularly with applications such as Office 365, which use font glyphs to display UI.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-185">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-185">Configuration options</span></span>

<span data-ttu-id="83fdd-186">**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-186">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="83fdd-187">그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-187">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="code-integrity-guard"></a><span data-ttu-id="83fdd-188">코드 무결성 가드</span><span class="sxs-lookup"><span data-stu-id="83fdd-188">Code integrity guard</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-189">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-189">Description</span></span>

<span data-ttu-id="83fdd-190">코드 무결성 보호는 프로세스에 로드된 모든 이진이 Microsoft에서 디지털 서명되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-190">Code integrity guard ensures that all binaries loaded into a process are digitally signed by Microsoft.</span></span> <span data-ttu-id="83fdd-191">코드 무결성 보호에는 [WHQL(Windows](/windows-hardware/drivers/install/whql-release-signature) 품질 랩) 서명이 포함되어 프로세스 내에서 WHQL 승인 드라이버를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-191">Code integrity guard includes [WHQL](/windows-hardware/drivers/install/whql-release-signature) (Windows Hardware Quality Labs) signatures, which will allow WHQL-approved drivers to run within the process.</span></span>

<span data-ttu-id="83fdd-192">이 완화는 메모리 관리자 내에서 구현됩니다. 이진 파일을 메모리에 매핑하지 못하게 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-192">This mitigation is implemented within the memory manager, which blocks the binary from being mapped into memory.</span></span> <span data-ttu-id="83fdd-193">Microsoft에서 서명하지 않은 이진 파일을 로드하려고 하면 메모리 관리에서 오류 메시지가 STATUS_INVALID_IMAGE_HASH.</span><span class="sxs-lookup"><span data-stu-id="83fdd-193">If you attempt to load a binary that is not signed by Microsoft, the memory manger will return the error STATUS_INVALID_IMAGE_HASH.</span></span> <span data-ttu-id="83fdd-194">메모리 관리자 수준에서 차단하면 프로세스에 의해 로드된 이진과 이진이 모두 프로세스에 주입되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-194">By blocking at the memory manager level, this prevents both binaries loaded by the process and binaries injected into the process.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-195">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-195">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-196">이 완화는 Microsoft에서 서명하지 않은 이진 파일을 특별히 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-196">This mitigation specifically blocks any binary that is not signed by Microsoft.</span></span> <span data-ttu-id="83fdd-197">따라서 소프트웨어가 해당 소프트웨어에 의해 배포(디지털 서명)된 경우와 Microsoft Store 서명된 이미지의 로드를 허용하는 옵션을 선택하지 않는 한 대부분의 타사 소프트웨어와 Microsoft Store 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-197">As such, it will be incompatible with most third-party software, unless that software is distributed by (and digitally signed by) the Microsoft Store, and the option to allow loading of images signed by the Microsoft Store is selected.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-198">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-198">Configuration options</span></span>

<span data-ttu-id="83fdd-199">**Microsoft Store** 서명된 이미지 로드 허용 - Microsoft Store 배포하는 응용 프로그램은 Microsoft Store 디지털 서명을 하게 며, 이 구성을 추가하면 저장소 인증 프로세스를 거쳤던 이진이 응용 프로그램에서 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-199">**Also allow loading of images signed by Microsoft Store** - Applications that are distributed by the Microsoft Store will be digitally signed by the Microsoft Store, and adding this configuration will allow binaries that have gone through the store certification process to be loaded by the application.</span></span>

<span data-ttu-id="83fdd-200">**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-200">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="83fdd-201">그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-201">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="control-flow-guard-cfg"></a><span data-ttu-id="83fdd-202">CFG(제어 흐름 보호)</span><span class="sxs-lookup"><span data-stu-id="83fdd-202">Control flow guard (CFG)</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-203">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-203">Description</span></span>

<span data-ttu-id="83fdd-204">CFG(제어 흐름 보호)는 간접 함수 호출을 보호하여 메모리 손상 취약성을 사용하는 공격자가 위험을 완화합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-204">Control flow guard (CFG) mitigates the risk of attackers using memory corruption vulnerabilities by protecting indirect function calls.</span></span> <span data-ttu-id="83fdd-205">예를 들어 공격자는 버퍼 오버플로 취약성을 사용하여 함수 포인터가 포함된 메모리를 덮어넣고 해당 함수 포인터를 선택한 실행 코드(프로그램에 삽입될 수도 있는)에 대한 포인터로 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-205">For example, an attacker may user a buffer overflow vulnerability to overwrite memory containing a function pointer, and replace that function pointer with a pointer to executable code of their choice (which may also have been injected into the program).</span></span>

<span data-ttu-id="83fdd-206">이 완화는 컴파일 시 다른 검사를 삽입하여 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-206">This mitigation is provided by injecting another check at compile time.</span></span> <span data-ttu-id="83fdd-207">각 간접 함수를 호출하기 전에 대상이 호출되기 전에 올바른 호출 대상이 올바른지 확인하는 다른 지침이 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-207">Before each indirect function call, another instructions are added which verify that the target is a valid call target before it is called.</span></span> <span data-ttu-id="83fdd-208">대상이 유효한 통화 대상이 아닌 경우 응용 프로그램이 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-208">If the target is not a valid call target, then the application is terminated.</span></span> <span data-ttu-id="83fdd-209">따라서 CFG 지원으로 컴파일된 응용 프로그램만 이 완화를 통해 혜택을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-209">As such, only applications that are compiled with CFG support can benefit from this mitigation.</span></span>

<span data-ttu-id="83fdd-210">올바른 대상에 대한 검사는 해당 커널에서 Windows 합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-210">The check for a valid target is provided by the Windows kernel.</span></span> <span data-ttu-id="83fdd-211">실행 파일이 로드되면 간접 통화 대상에 대한 메타데이터가 로드 시 추출되고 유효한 통화 대상으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-211">When executable files are loaded, the metadata for indirect call targets is extracted at load time and marked as valid call targets.</span></span> <span data-ttu-id="83fdd-212">또한 메모리가 할당되고 생성된 코드와 같은 실행 가능으로 표시되면 이러한 메모리 위치도 유효한 호출 대상으로 표시되어 JIT 컴파일과 같은 메커니즘을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-212">Additionally, when memory is allocated and marked as executable (such as for generated code), these memory locations are also marked as valid call targets, to support mechanisms such as JIT compilation.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-213">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-213">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-214">CFG를 지원하기 위해 응용 프로그램을 컴파일해야 하기 때문에 응용 프로그램과의 호환성을 암시적으로 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-214">Since applications must be compiled to support CFG, they implicitly declare their compatibility with it.</span></span> <span data-ttu-id="83fdd-215">따라서 대부분의 응용 프로그램은 이 완화 기능을 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-215">Most applications, therefore, should work with this mitigation enabled.</span></span> <span data-ttu-id="83fdd-216">이러한 검사는 이진 파일로 컴파일되어 있기 때문에 적용할 수 있는 구성은 커널 내에서 확인을 사용하지 않도록 Windows 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-216">Because these checks are compiled into the binary, the configuration you can apply is merely to disable checks within the Windows kernel.</span></span> <span data-ttu-id="83fdd-217">즉, 완화는 기본적으로 설정되어 있지만 나중에 응용 프로그램 개발자가 테스트에서 검색하지 못했다는 호환성 문제가 확인되면 항상 "예"를 반환하도록 Windows 커널을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-217">In other words, the mitigation is on by default, but you can configure the Windows kernel to always return "yes" if you later determine that there is a compatibility issue that the application developer did not discover in their testing, which should be rare.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-218">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-218">Configuration options</span></span>

<span data-ttu-id="83fdd-219">**엄격한 CFG** 사용 - 엄격한 모드에서 프로세스에 로드된 모든 이진은 로드하려면 Control Flow Guard에 대해 컴파일해야 합니다(또는 리소스 dll과 같은 실행 코드가 없는 경우).</span><span class="sxs-lookup"><span data-stu-id="83fdd-219">**Use strict CFG** - In strict mode, all binaries loaded into the process must be compiled for Control Flow Guard (or have no executable code in them - such as resource dlls) in order to be loaded.</span></span>

> [!Note]
> <span data-ttu-id="83fdd-220">**제어 흐름 보호에는** 감사 모드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-220">**Control flow guard** has no audit mode.</span></span> <span data-ttu-id="83fdd-221">이 완화를 사용하도록 설정된 이진이 컴파일됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-221">Binaries are compiled with this mitigation enabled.</span></span>

## <a name="data-execution-prevention-dep"></a><span data-ttu-id="83fdd-222">데이터 실행 방지(DEP)</span><span class="sxs-lookup"><span data-stu-id="83fdd-222">Data Execution Prevention (DEP)</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-223">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-223">Description</span></span>

<span data-ttu-id="83fdd-224">DEP(데이터 실행 방지)는 실행 가능으로 명시적으로 할당되지 않은 메모리가 실행되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-224">Data execution prevention (DEP) prevents memory that was not explicitly allocated as executable from being executed.</span></span> <span data-ttu-id="83fdd-225">DEP는 버퍼 오버플로를 통해 악성 코드를 주입한 다음 해당 코드를 실행하는 공격자로부터 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-225">DEP helps protect against an attacker injecting malicious code into the process, such as through a buffer overflow, and then executing that code.</span></span>

<span data-ttu-id="83fdd-226">명령 포인터를 실행 가능으로 표시되지 않은 메모리 주소로 설정하려고 하면 프로세서에서 예외(일반 보호 위반)를 발생하여 응용 프로그램이 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-226">If you attempt to set the instruction pointer to a memory address not marked as executable, the processor will throw an exception (general-protection violation), causing the application to crash.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-227">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-227">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-228">모든 x64, ARM 및 ARM-64 실행은 기본적으로 DEP를 사용하도록 설정되어 있으며 사용하지 않도록 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-228">All x64, ARM, and ARM-64 executables have DEP enabled by default, and it cannot be disabled.</span></span> <span data-ttu-id="83fdd-229">응용 프로그램이 DEP 없이 실행된 적이 없는 것이기 때문에 호환성이 가정됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-229">Since an application will have never been executed without DEP, compatibility is assumed.</span></span>

<span data-ttu-id="83fdd-230">모든 x86(32비트) 이진은 기본적으로 DEP를 사용하도록 설정되어 있지만 프로세스당 DEP를 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-230">All x86 (32-bit) binaries have DEP enabled by default, but DEP can be disabled per process.</span></span> <span data-ttu-id="83fdd-231">일부 이전 레거시 응용 프로그램(일반적으로 XP SP2 이전에 Windows 응용 프로그램은 DEP와 호환되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-231">Some old legacy applications, typically applications developed prior to Windows XP SP2, might not be compatible with DEP.</span></span> <span data-ttu-id="83fdd-232">이러한 응용 프로그램은 일반적으로 코드를 동적으로 생성하거나(예: JIT 컴파일) 또는 코드를 동적으로 생성하는 이전 버전의 ATL과 같은 이전 라이브러리에 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-232">Such applications typically generate code dynamically (for example, JIT compiling) or link to older libraries (such as older versions of ATL) which dynamically generate code.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-233">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-233">Configuration options</span></span>

<span data-ttu-id="83fdd-234">**ATL Thunk 에뮬ation** 사용 - 이 구성 옵션은 ATL Thunk 에뮬ATION을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-234">**Enable ATL Thunk emulation** - This configuration option disables ATL Thunk emulation.</span></span> <span data-ttu-id="83fdd-235">기본 ActiveX 라이브러리인 ATL은 최대한 작고 빠르게 설계됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-235">ATL, the ActiveX Template Library, is designed to be as small and fast as possible.</span></span> <span data-ttu-id="83fdd-236">이진 크기를 줄이기 위해 *스킹(thunking)이라는 기술을 사용합니다.*</span><span class="sxs-lookup"><span data-stu-id="83fdd-236">In order to reduce binary size, it would use a technique called *thunking*.</span></span> <span data-ttu-id="83fdd-237">번킹은 일반적으로 32비트 응용 프로그램과 16비트 응용 프로그램 간에 상호 작용하는 것으로 생각되지만 ATL에는 16비트 구성 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-237">Thunking is typically thought of for interacting between 32-bit and 16-bit applications, but there are no 16-bit components to ATL here.</span></span> <span data-ttu-id="83fdd-238">대신 이진 크기에 최적화하기 위해 ATL은 단어 맞춤이 아닌 컴퓨터 코드를 메모리에 저장한 다음(더 작은 이진 파일을 생성) 해당 코드를 직접 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-238">Rather, in order to optimize for binary size, ATL will store machine code in memory that is not word-aligned (creating a smaller binary), and then invoke that code directly.</span></span> <span data-ttu-id="83fdd-239">Visual Studio 7.1 또는 이전 버전(Visual Studio 2003)으로 컴파일된 ATL 구성 요소는 이 메모리를 실행 가능으로 할당하지 않습니다. unk 에뮬ATION은 호환성 문제를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-239">ATL components compiled with Visual Studio 7.1 or earlier (Visual Studio 2003) do not allocate this memory as executable - thunk emulation resolves that compatibility issue.</span></span> <span data-ttu-id="83fdd-240">이진 확장 모델(예: Internet Explorer 11)을 사용하는 응용 프로그램에는 ATL Thunk 에뮬션을 사용하도록 설정해야 하는 경우가 종종 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-240">Applications that have a binary extension model (such as Internet Explorer 11) will often need to have ATL Thunk emulation enabled.</span></span>

## <a name="disable-extension-points"></a><span data-ttu-id="83fdd-241">확장 지점 사용 안 함</span><span class="sxs-lookup"><span data-stu-id="83fdd-241">Disable extension points</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-242">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-242">Description</span></span>

<span data-ttu-id="83fdd-243">이 완화는 응용 프로그램에 대한 다양한 확장 지점을 사용하지 않도록 설정하여 악의적인 콘텐츠의 지속성 설정 또는 권한 상승에 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-243">This mitigation disables various extension points for an application, which might be used to establish persistence or elevate privileges of malicious content.</span></span>

<span data-ttu-id="83fdd-244">여기에는 다음이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-244">This includes:</span></span>

- <span data-ttu-id="83fdd-245">**AppInit DLL** - 프로세스가 시작될 때마다 시스템은 진입점 함수를 호출하기 전에 지정된 DLL을 새로 시작된 프로세스의 컨텍스트로 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-245">**AppInit DLLs** - Whenever a process starts, the system will load the specified DLL into to context of the newly started process before calling its entry point function.</span></span> <span data-ttu-id="83fdd-246">[AppInit DLS에 대한 자세한 내용은 에서 찾을 수 있습니다.](/windows/win32/winmsg/about-window-classes#application-global-classes)</span><span class="sxs-lookup"><span data-stu-id="83fdd-246">[Details on AppInit DLLs can be found here](/windows/win32/winmsg/about-window-classes#application-global-classes).</span></span> <span data-ttu-id="83fdd-247">이 완화를 적용하면 AppInit DL이 로드되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-247">With this mitigation applied, AppInit DLLs are not loaded.</span></span> <span data-ttu-id="83fdd-248">Windows 7부터는 여기에 설명된 바와 같이 AppInit DLS에 디지털 [서명이 필요합니다.](/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2)</span><span class="sxs-lookup"><span data-stu-id="83fdd-248">Beginning with Windows 7, AppInit DLLs need to be digitally signed, [as described here](/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2).</span></span> <span data-ttu-id="83fdd-249">또한 여기서 설명하는 Windows 8 AppInit DL은 SecureBoot을 사용하도록 설정한 경우 [로드되지 않습니다.](/windows/win32/dlls/secure-boot-and-appinit-dlls)</span><span class="sxs-lookup"><span data-stu-id="83fdd-249">Additionally, beginning with Windows 8, AppInit DLLs will not be loaded if SecureBoot is enabled, [as described here](/windows/win32/dlls/secure-boot-and-appinit-dlls).</span></span>
- <span data-ttu-id="83fdd-250">**레거시** IME(입력기) - 사용자가 키보드에서 표시될 수 있는 것보다 많은 문자가 있는 언어로 텍스트를 입력할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-250">**Legacy IMEs** - An Input Method Editor (IME) allows a user to type text in a language that has more characters than can be represented on a keyboard.</span></span> <span data-ttu-id="83fdd-251">타사에서 IM을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-251">Third parties are able to create IMEs.</span></span> <span data-ttu-id="83fdd-252">악의적인 IME는 이 입력 캡처에서 자격 증명 또는 기타 중요한 정보를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-252">A malicious IME might obtain credentials or other sensitive information from this input capture.</span></span> <span data-ttu-id="83fdd-253">레거시 IM이라고 하는 일부 IM은 UWP 앱이 Windows 데스크톱 앱에서만 작동됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-253">Some IMEs, referred to as Legacy IMEs, will only work on Windows Desktop apps, and not UWP apps.</span></span> <span data-ttu-id="83fdd-254">또한 이 완화는 이 레거시 IME가 지정된 데스크톱 앱으로 Windows 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-254">This mitigation will also prevent this legacy IME from loading into the specified Windows Desktop app.</span></span>
- <span data-ttu-id="83fdd-255">**Windows 후크** - 응용 프로그램에서 [SetWinEventHook API를](/windows/win32/api/winuser/nf-winuser-setwineventhook) 호출하여 이벤트 발생 시 관심을 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-255">**Windows Event Hooks** - An application can call the [SetWinEventHook API](/windows/win32/api/winuser/nf-winuser-setwineventhook) to register interest in an event taking place.</span></span> <span data-ttu-id="83fdd-256">DLL이 지정되어 프로세스에 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-256">A DLL is specified and can be injected into the process.</span></span> <span data-ttu-id="83fdd-257">이 완화는 삽입된 DLL을 통해 In-process를 실행하는 대신 등록 프로세스에 후크를 강제로 게시합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-257">This mitigation forces the hook to be posted to the registering process rather than running in-process through an injected DLL.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-258">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-258">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-259">이러한 확장 지점은 대부분 비교적 적게 사용되지 않습니다. 따라서 호환성에 미치는 영향은 일반적으로 작고 특히 개별 응용 프로그램 수준에서는 그렇습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-259">Most of these extension points are relatively infrequently used, so compatibility impact is typically small, particularly at an individual application level.</span></span> <span data-ttu-id="83fdd-260">한 가지 고려 사항은 사용자가 보호된 응용 프로그램에서 작동하지 않는 타사 레거시 IM을 사용하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-260">The one consideration is if users are using third-party Legacy IMEs that will not work with the protected application.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-261">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-261">Configuration options</span></span>

<span data-ttu-id="83fdd-262">이 완화를 위한 구성 옵션은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-262">There are no configuration options for this mitigation.</span></span>

> [!Note]
> <span data-ttu-id="83fdd-263">**확장점을 사용하지 않도록 설정하는** 경우 감사 모드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-263">**Disable extension points** has no audit mode.</span></span>

## <a name="disable-win32k-system-calls"></a><span data-ttu-id="83fdd-264">Win32k 시스템 호출 사용 안 함</span><span class="sxs-lookup"><span data-stu-id="83fdd-264">Disable Win32k system calls</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-265">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-265">Description</span></span>

<span data-ttu-id="83fdd-266">Win32k.sys 공격자는 광범위한 공격 표면을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-266">Win32k.sys provides a broad attack surface for an attacker.</span></span> <span data-ttu-id="83fdd-267">커널 모드 구성 요소로 샌드박스가 적용된 응용 프로그램에 대한 이스케이프 벡터로 대상이 지정되는 경우도 잦습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-267">As a kernel-mode component, it is frequently targeted as an escape vector for applications that are sandboxed.</span></span> <span data-ttu-id="83fdd-268">이 완화는 스레드가 자체적으로 GUI 스레드로 변환되지 않도록 차단하여 win32k.sys 호출을 방지합니다. 그런 다음 Win32k 함수를 호출할 수 있는 액세스 권한이 부여됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-268">This mitigation prevents calls into win32k.sys by blocking a thread from converting itself into a GUI thread, which is then given access to invoke Win32k functions.</span></span> <span data-ttu-id="83fdd-269">스레드는 만들 때 GUI가 아닌 것이지만 첫 번째 호출 시 또는 [IsGuiThread에](/windows/win32/api/winuser/nf-winuser-isguithread)win32k.sys API 호출을 통해 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-269">A thread is non-GUI when created, but converted on first call to win32k.sys, or through an API call to [IsGuiThread](/windows/win32/api/winuser/nf-winuser-isguithread).</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-270">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-270">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-271">이 완화는 전용 비 UI 프로세스인 프로세스에 대해 고안되었습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-271">This mitigation is designed for processes that are dedicated non-UI processes.</span></span> <span data-ttu-id="83fdd-272">예를 들어 대부분의 최신 브라우저는 프로세스의 고리와 비 UI 프로세스를 통합합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-272">For example, many modern browsers will use process isolation and incorporate non-UI processes.</span></span> <span data-ttu-id="83fdd-273">단일 프로세스를 사용하여 GUI를 표시하는 응용 프로그램은 이 완화의 영향을 하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-273">Any application that displays a GUI using a single process will be impacted by this mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-274">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-274">Configuration options</span></span>

<span data-ttu-id="83fdd-275">**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-275">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="83fdd-276">그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-276">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="do-not-allow-child-processes"></a><span data-ttu-id="83fdd-277">자식 프로세스 허용 안 함</span><span class="sxs-lookup"><span data-stu-id="83fdd-277">Do not allow child processes</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-278">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-278">Description</span></span>

<span data-ttu-id="83fdd-279">이 완화를 통해 응용 프로그램에서 새 자식 응용 프로그램을 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-279">This mitigation prevents an application from creating new child applications.</span></span> <span data-ttu-id="83fdd-280">악의적인 입력("육지에서 살기" 공격)을 사용하여 디바이스에서 신뢰할 수 있는 프로세스를 시작하는 데 사용되는 일반적인 기술은 종종 장치에서 다른 응용 프로그램을 실행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-280">A common technique used by adversaries is to initiate a trusted process on the device with malicious input (a "living off the land" attack), which often requires launching another application on the device.</span></span> <span data-ttu-id="83fdd-281">응용 프로그램에서 자식 프로세스를 시작하게 하는 정당한 이유가 없는 경우 이러한 완화는 잠재적인 공격 벡터를 완화합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-281">If there are no legitimate reasons why an application would launch a child process, this mitigation mitigates that potential attack vector.</span></span> <span data-ttu-id="83fdd-282">이 완화는 오류 메시지가 표시되어 있는 자식 프로세스에 대한 토큰을 만드는 데 차단하는 프로세스 토큰에 속성을 설정하여 STATUS_CHILD_PROCESS_BLOCKED.</span><span class="sxs-lookup"><span data-stu-id="83fdd-282">The mitigation is applied by setting a property on the process token, which blocks creating a token for the child process with the error message STATUS_CHILD_PROCESS_BLOCKED.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-283">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-283">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-284">응용 프로그램에서 브라우저 또는 외부 브라우저를 시작하거나 컴퓨터에서 다른 유틸리티를 실행하는 하이퍼링크 지원과 같은 이유로 자식 응용 프로그램을 시작하면 이 완화가 적용되어 이 기능이 손상됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-284">If your application launches child applications for any reason, such as supporting hyperlinks that launch a browser or an external browser, or which launch other utilities on the computer, this functionality will be broken with this mitigation applied.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-285">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-285">Configuration options</span></span>

<span data-ttu-id="83fdd-286">**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-286">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="83fdd-287">그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-287">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="export-address-filtering"></a><span data-ttu-id="83fdd-288">주소 필터링 내보내기</span><span class="sxs-lookup"><span data-stu-id="83fdd-288">Export address filtering</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-289">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-289">Description</span></span>

<span data-ttu-id="83fdd-290">EAF(내보내기 주소 필터링)는 로드된 모든 모듈의 내보내기 주소 테이블을 확인하여 공격에 유용한 API가 포함된 모듈을 찾는 악성 코드의 위험을 완화합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-290">Export address filtering (EAF) mitigates the risk of malicious code looking at the export address table of all loaded modules to find modules that contain useful APIs for their attack.</span></span> <span data-ttu-id="83fdd-291">이는 셸 코드에서 사용되는 일반적인 전략입니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-291">This is a common tactic used by shellcode.</span></span> <span data-ttu-id="83fdd-292">이러한 공격의 위험을 완화하기 위해 이 완화는 일반적으로 공격하는 세 가지 모듈을 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-292">In order to mitigate the risk of such an attack, this mitigation protects three commonly attacked modules:</span></span>

- <span data-ttu-id="83fdd-293">ntdll.dll</span><span class="sxs-lookup"><span data-stu-id="83fdd-293">ntdll.dll</span></span>
- <span data-ttu-id="83fdd-294">kernelbase.dll</span><span class="sxs-lookup"><span data-stu-id="83fdd-294">kernelbase.dll</span></span>
- <span data-ttu-id="83fdd-295">kernel32.dll</span><span class="sxs-lookup"><span data-stu-id="83fdd-295">kernel32.dll</span></span>

<span data-ttu-id="83fdd-296">이 완화는 [export 디렉터리에서 내보내기 주소 테이블을 지점으로 하는 메모리 [페이지를 보호합니다.](/windows/win32/debug/pe-format#export-address-table)</span><span class="sxs-lookup"><span data-stu-id="83fdd-296">The mitigation protects the memory page in the [export directory that points to the [export address table](/windows/win32/debug/pe-format#export-address-table).</span></span> <span data-ttu-id="83fdd-297">이 메모리 페이지에는 PAGE_GUARD [보호가](/windows/win32/memory/creating-guard-pages) 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-297">This memory page will have the [PAGE_GUARD](/windows/win32/memory/creating-guard-pages) protection applied to it.</span></span> <span data-ttu-id="83fdd-298">누군가 이 메모리에 액세스하면 메모리가 STATUS_GUARD_PAGE_VIOLATION.</span><span class="sxs-lookup"><span data-stu-id="83fdd-298">When someone tries to access this memory, it will generate a STATUS_GUARD_PAGE_VIOLATION.</span></span> <span data-ttu-id="83fdd-299">이 완화는 이 예외를 처리하며 액세스 명령이 유효성 검사를 통과하지 못하면 프로세스가 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-299">The mitigation handles this exception, and if the accessing instruction doesn't pass validation, the process will be terminated.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-300">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-300">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-301">이 완화는 주로 디버거, 샌드박스 응용 프로그램, DRM을 사용하는 응용 프로그램 또는 디버깅 방지 기술을 구현하는 응용 프로그램과 같은 응용 프로그램에 대한 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-301">This mitigation is primarily an issue for applications such as debuggers, sandboxed applications, applications using DRM, or applications that implement anti-debugging technology.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-302">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-302">Configuration options</span></span>

<span data-ttu-id="83fdd-303">**악용으로** 악용되는 모듈에 대한 액세스 유효성 검사 - EAF+라고도 하는 이 옵션은 일반적으로 공격하는 다른 모듈에 대한 보호 기능을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-303">**Validate access for modules that are commonly abused by exploits** - This option, also known as EAF+, adds protections for other commonly attacked modules:</span></span>

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

<span data-ttu-id="83fdd-304">또한 EAF+를 사용하도록 설정하여 이 완화는 셸코드가 메모리에서 잠재적으로 관심이 있는 모듈을 식별하기 위해 검색할 수 있는 알려진 메모리 콘텐츠의 또 다른 측면인 "MZ" 헤더인 "MZ" 헤더가 포함된 페이지에 PAGE_GUARD 보호를 추가합니다. [](/windows/win32/debug/pe-format#ms-dos-stub-image-only)</span><span class="sxs-lookup"><span data-stu-id="83fdd-304">Additionally, by enabling EAF+, this mitigation adds the PAGE_GUARD protection to the page containing the "MZ" header, the first two bytes of the [DOS header in a PE file](/windows/win32/debug/pe-format#ms-dos-stub-image-only), which is another aspect of known memory content which shellcode can look for to identify modules potentially of interest in memory.</span></span>

<span data-ttu-id="83fdd-305">**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-305">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="83fdd-306">그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-306">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="force-randomization-for-images-mandatory-aslr"></a><span data-ttu-id="83fdd-307">이미지에 대한 강제 임의 지정(필수 ASLR)</span><span class="sxs-lookup"><span data-stu-id="83fdd-307">Force randomization for images (Mandatory ASLR)</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-308">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-308">Description</span></span>

<span data-ttu-id="83fdd-309">ASLR(Address Space Layout Randomization)을 통해 공격자가 시스템의 메모리 레이아웃에 대한 지식을 사용하여 이미 프로세스 메모리에 있으며 실행 가능으로 표시된 코드를 실행할 위험을 완화합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-309">Address Space Layout Randomization (ASLR) mitigates the risk of an attacker using their knowledge of the memory layout of the system in order to execute code that is already present in process memory and already marked as executable.</span></span> <span data-ttu-id="83fdd-310">이렇게 하면 반송 공격자가 컨텍스트를 설정한 다음 반송 주소를 수정하여 적의 목적에 적합한 컨텍스트를 사용하여 기존 코드를 실행하도록 공격자가 위험을 완화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-310">This can mitigate the risk of an attacker using techniques such as return-to-libc attacks, where the adversary sets the context and then modifies the return address to execute existing code with context that suits the adversary's purpose.</span></span>

<span data-ttu-id="83fdd-311">필수 ASLR은 프로세스 내의 모든 DL을 강제로 다시베이스합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-311">Mandatory ASLR forces a rebase of all DLLs within the process.</span></span> <span data-ttu-id="83fdd-312">개발자는 [/DYNAMICBASE](/cpp/build/reference/dynamicbase-use-address-space-layout-randomization) 링커 옵션을 사용하여 ASLR을 사용하도록 설정할 수 있으며 이 완화는 동일한 영향을 미치게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-312">A developer can enable ASLR using the [/DYNAMICBASE](/cpp/build/reference/dynamicbase-use-address-space-layout-randomization) linker option, and this mitigation has the same effect.</span></span>

<span data-ttu-id="83fdd-313">메모리 관리자가 이미지에서 프로세스로 매핑하는 경우 필수 ASLR은 ASLR에 옵트인하지 않은 DLL 및 EXES를 강제로 다시베이스합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-313">When the memory manager is mapping in the image into the process, Mandatory ASLR will forcibly rebase DLLs and EXEs that have not opted in to ASLR.</span></span> <span data-ttu-id="83fdd-314">그러나 이 재지정은 인트로피가 없습니다. 따라서 메모리의 예측 가능한 위치에 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-314">Note, however, that this rebasing has no entropy, and can therefore be placed at a predictable location in memory.</span></span> <span data-ttu-id="83fdd-315">이진의 재지정 및 임의 위치의 경우 이 완화는 임의로 메모리 할당(상하 [ASLR)과](#randomize-memory-allocations-bottom-up-aslr)쌍을 이루는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-315">For rebased and randomized location of binaries, this mitigation should be paired with [Randomize memory allocations (Bottom-up ASLR)](#randomize-memory-allocations-bottom-up-aslr).</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-316">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-316">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-317">ASLR의 이러한 호환성 영향은 일반적으로 이진 파일의 기본 주소에 대해 가정하거나 기본 재배치 정보를 제거한 컴파일러를 사용하여 만든 이전 응용 프로그램으로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-317">This compatibility impact of ASLR is typically constrained to older applications that were built using compilers that made assumptions about the base address of a binary file or have stripped out base relocation information.</span></span> <span data-ttu-id="83fdd-318">이로 인해 실행 흐름이 메모리의 실제 위치가 아니라 예상한 위치로 이동하려고 할 때 예측할 수 없는 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-318">This can lead to unpredictable errors as the execution flow attempts to jump to the expected, rather than the actual, location in memory.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-319">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-319">Configuration options</span></span>

<span data-ttu-id="83fdd-320">**제거된** 이미지를 허용하지 않습니다. 이 옵션은 재배치 정보가 제거된 이미지의 로드를 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-320">**Do not allow stripped images** - This option blocks the loading of images that have had relocation information stripped.</span></span> <span data-ttu-id="83fdd-321">Windows PE 파일 형식은 절대 주소를 포함하며, 컴파일러는 로더가 모든 상대 메모리 참조와 해당 오프셋을 찾는 데 사용할 수 있는 [기본 위치 변경 테이블]을 생성하여 이진 파일이 기본 기본 주소에서 로드되지 않는 경우 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-321">The Windows PE file format contains absolute addresses, and the compiler also generates a [base relocation table that the loader can use to find all relative memory references and their offset, so they can be updated if the binary does not load at its preferred base address.</span></span> <span data-ttu-id="83fdd-322">일부 이전 응용 프로그램은 프로덕션 빌드에서 이 정보를 제거하므로 이러한 이진은 다시 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-322">Some older applications strip out this information in production builds, and therefore these binaries cannot be rebased.</span></span> <span data-ttu-id="83fdd-323">이 완화는 이러한 이진이 기본 기본 주소로 로드되는 것을 허용하는 대신 로드되지 못하게 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-323">This mitigation blocks such binaries from being loaded (instead of allowing them to load at their preferred base address).</span></span>

> [!Note]
> <span data-ttu-id="83fdd-324">**이미지에 대한 임의 설정 강제(필수 ASLR)에는** 감사 모드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-324">**Force randomization for images (Mandatory ASLR)** has no audit mode.</span></span>

## <a name="import-address-filtering-iaf"></a><span data-ttu-id="83fdd-325">주소 필터링 가져오기(IAF)</span><span class="sxs-lookup"><span data-stu-id="83fdd-325">Import address filtering (IAF)</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-326">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-326">Description</span></span>

<span data-ttu-id="83fdd-327">IAF(가져오기 주소 필터링) 완화는 IAT(가져오기 주소 테이블)를 수정하여 해당 함수가 호출될 때 공격자가 선택한 임의의 코드로 리디렉션하도록 수정하여 응용 프로그램의 제어 흐름을 변경하는 공격자 위험을 완화하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-327">The import address filtering (IAF) mitigation helps mitigate the risk of an adversary changing the control flow of an application by modifying the import address table (IAT) to redirect to arbitrary code of the attacker's choice when that function is called.</span></span> <span data-ttu-id="83fdd-328">공격자는 이 방법을 사용하여 제어를 숨기거나 중요한 API에 대한 호출을 가로채고 검사하고 차단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-328">An attacker could use this approach to hijack control, or to intercept, inspect, and potentially block calls to sensitive APIs.</span></span>

<span data-ttu-id="83fdd-329">보호된 모든 API의 메모리 페이지에는 PAGE_GUARD [보호가](/windows/win32/memory/creating-guard-pages) 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-329">The memory pages for all protected APIs will have the [PAGE_GUARD](/windows/win32/memory/creating-guard-pages) protection applied to them.</span></span> <span data-ttu-id="83fdd-330">누군가 이 메모리에 액세스하면 메모리가 STATUS_GUARD_PAGE_VIOLATION.</span><span class="sxs-lookup"><span data-stu-id="83fdd-330">When someone tries to access this memory, it will generate a STATUS_GUARD_PAGE_VIOLATION.</span></span> <span data-ttu-id="83fdd-331">이 완화는 이 예외를 처리하며 액세스 명령이 유효성 검사를 통과하지 못하면 프로세스가 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-331">The mitigation handles this exception, and if the accessing instruction doesn't pass validation, the process will be terminated.</span></span>

<span data-ttu-id="83fdd-332">이 완화는 다음과 같은 Windows 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-332">This mitigation protects the following Windows APIs:</span></span>

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-333">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-333">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-334">이러한 완화로 인해 API 가로채기를 수행하는 합법적인 응용 프로그램이 검색되고 일부 응용 프로그램이 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-334">Legitimate applications that perform API interception may be detected by this mitigation and cause some applications to crash.</span></span> <span data-ttu-id="83fdd-335">보안 소프트웨어 및 응용 프로그램 호환성 shims를 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-335">Examples include security software and application compatibility shims.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-336">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-336">Configuration options</span></span>

<span data-ttu-id="83fdd-337">**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-337">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="83fdd-338">그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-338">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="randomize-memory-allocations-bottom-up-aslr"></a><span data-ttu-id="83fdd-339">임의로 메모리 할당(상하 ASLR)</span><span class="sxs-lookup"><span data-stu-id="83fdd-339">Randomize memory allocations (Bottom-up ASLR)</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-340">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-340">Description</span></span>

<span data-ttu-id="83fdd-341">임의로 메모리 할당(상하 ASLR)을 수행하면 위치가 임의화 하므로 예측 가능하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-341">Randomize memory allocations (Bottom-up ASLR) adds entropy to relocations, so their location is randomized and therefore less predictable.</span></span> <span data-ttu-id="83fdd-342">이 완화를 적용하려면 필수 ASLR이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-342">This mitigation requires Mandatory ASLR to take effect.</span></span>

<span data-ttu-id="83fdd-343">32비트 주소 공간의 크기는 추가할 수 있는 entropy에 실질적인 제약 조건을 적용하므로 64비트 응용 프로그램을 사용하는 경우 공격자가 메모리의 위치를 추측하기가 더 어려워질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-343">The size of the 32-bit address space places practical constraints on the entropy that can be added, and therefore 64-bit applications make it more difficult for an attacker to guess a location in memory.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-344">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-344">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-345">필수 ASLR(보스)과 호환되는 대부분의 응용 프로그램은 상한 ASLR의 다른 항목과도 호환됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-345">Most applications that are compatible with Mandatory ASLR (rebasing) are also compatible with the other entropy of Bottom-up ASLR.</span></span> <span data-ttu-id="83fdd-346">일부 응용 프로그램은 로컬 포인터를 32비트 변수(기본 주소가 4GB 미만으로 예상)에 저장하는 경우 포인터 잘라 내기 문제가 있을 수 있으며, 따라서 사용하지 않도록 설정할 수 있는 높은 엔트로피 옵션과는 무관합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-346">Some applications may have pointer-truncation issues if they are saving local pointers in 32-bit variables (expecting a base address below 4 GB), and thus will be incompatible with the high entropy option (which can be disabled).</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-347">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-347">Configuration options</span></span>

<span data-ttu-id="83fdd-348">**높은 entropy를** 사용하지 않도록 설정 - 이 옵션은 64비트 응용 프로그램에 대한 상한 할당에 24비트(1 TB의 분배)를 추가하는 높은 entropy ASLR 사용을 사용하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-348">**Don't use high entropy** - this option disables the use of high-entropy ASLR, which adds 24 bits of entropy (1 TB of variance) into the bottom-up allocation for 64-bit applications.</span></span>

> [!Note]
> <span data-ttu-id="83fdd-349">**임의로 메모리 할당(상하 ASLR)에는** 감사 모드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-349">**Randomize memory allocations (Bottom-up ASLR)** has no audit mode.</span></span>

## <a name="simulate-execution-simexec"></a><span data-ttu-id="83fdd-350">실행 시뮬레이션(SimExec)</span><span class="sxs-lookup"><span data-stu-id="83fdd-350">Simulate execution (SimExec)</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-351">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-351">Description</span></span>

<span data-ttu-id="83fdd-352">시뮬레이트 실행(SimExec)은 32비트 응용 프로그램에만 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-352">Simulate execution (SimExec) is a mitigation for 32-bit applications only.</span></span> <span data-ttu-id="83fdd-353">이렇게 하면 중요한 API에 대한 호출이 합법적인 호출자 기능으로 돌아가는지 검사하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-353">This helps validate that calls to sensitive APIs will return to legitimate caller functions.</span></span> <span data-ttu-id="83fdd-354">이 작업에서는 중요한 API에 대한 호출을 가로채고 호출자에게 돌아가야 하는 RET 명령을 찾는 인코딩된 어셈블리 언어 지침을 따라 실행을 시뮬레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-354">It does this by intercepting calls into sensitive APIs, and then simulating the execution of those APIs by walking through the encoded assembly language instructions looking for the RET instruction, which should return to the caller.</span></span> <span data-ttu-id="83fdd-355">그런 다음 해당 함수를 검사하고 메모리에서 뒤로를 따라 앞의 CALL 명령을 찾아 함수와 CALL 명령이 일치하는지 여부와 RET이 가로채지 않은지 여부를 파악합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-355">It then inspects that function and walks backwards in memory to find the preceding CALL instruction to determine whether the function and CALL instruction match, and that the RET hasn't been intercepted.</span></span>

<span data-ttu-id="83fdd-356">이 완화로 가로채진 API는 다음입니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-356">The APIs intercepted by this mitigation are:</span></span>

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

<span data-ttu-id="83fdd-357">ROP 가제트가 감지되면 프로세스가 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-357">If a ROP gadget is detected, the process is terminated.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-358">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-358">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-359">API 가로채기(특히 보안 소프트웨어)를 수행하는 응용 프로그램은 이 완화로 호환성 문제를 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-359">Applications that perform API interception, particularly security software, can cause compatibility problems with this mitigation.</span></span>

<span data-ttu-id="83fdd-360">이 완화는 임의 Code Guard 완화와는 무관합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-360">This mitigation is incompatible with the Arbitrary Code Guard mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-361">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-361">Configuration options</span></span>

<span data-ttu-id="83fdd-362">**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-362">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="83fdd-363">그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-363">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="validate-api-invocation-callercheck"></a><span data-ttu-id="83fdd-364">API 호출 확인(CallerCheck)</span><span class="sxs-lookup"><span data-stu-id="83fdd-364">Validate API invocation (CallerCheck)</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-365">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-365">Description</span></span>

<span data-ttu-id="83fdd-366">API 호출 유효성 검사(CallerCheck)는 유효한 호출자로부터 중요한 API가 호출된 것이 유효한지 검사하는 ROP(반환 지향 프로그래밍) 기술에 대한 완화입니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-366">Validate API invocation (CallerCheck) is a mitigation for return-oriented programming (ROP) techniques that validates that sensitive APIs were called from a valid caller.</span></span> <span data-ttu-id="83fdd-367">이 완화는 전달된 반환 주소를 검사한 다음 역으로 분해하여 반환 주소 위에 있는 호출을 찾아 호출 대상이 함수로 전달된 매개 변수와 일치하는지 여부를 판단합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-367">This mitigation inspects the passed return address, and then heuristically disassembles backwards to find a call above the return address to determine if the call target matches the parameter passed into the function.</span></span>

<span data-ttu-id="83fdd-368">이 완화로 가로채진 API는 다음입니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-368">The APIs intercepted by this mitigation are:</span></span>

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

<span data-ttu-id="83fdd-369">ROP 가제트가 감지되면 프로세스가 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-369">If a ROP gadget is detected, the process is terminated.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-370">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-370">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-371">API 가로채기(특히 보안 소프트웨어)를 수행하는 응용 프로그램은 이 완화로 호환성 문제를 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-371">Applications that perform API interception, particularly security software, can cause compatibility problems with this mitigation.</span></span>

<span data-ttu-id="83fdd-372">이 완화는 임의 Code Guard 완화와는 무관합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-372">This mitigation is incompatible with the Arbitrary Code Guard mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-373">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-373">Configuration options</span></span>

<span data-ttu-id="83fdd-374">**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-374">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="83fdd-375">그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-375">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="validate-exception-chains-sehop"></a><span data-ttu-id="83fdd-376">예외 체인 확인(SEHOP)</span><span class="sxs-lookup"><span data-stu-id="83fdd-376">Validate exception chains (SEHOP)</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-377">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-377">Description</span></span>

<span data-ttu-id="83fdd-378">SEHOP(예외 체인 유효성 검사)는 *SEH(구조적* 예외 처리기) 덮어 사용 기술에 대한 완화입니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-378">Validate exception chains (SEHOP) is a mitigation against the *Structured Exception Handler (SEH) overwrite* exploitation technique.</span></span> <span data-ttu-id="83fdd-379">[구조화된 예외 처리는](/windows/win32/debug/structured-exception-handling) 응용 프로그램에서 특정 예외를 처리하기 위해 요청하는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-379">[Structured exception handling](/windows/win32/debug/structured-exception-handling) is the process by which an application can ask to handle a particular exception.</span></span> <span data-ttu-id="83fdd-380">예외 처리기도 함께 연결됩니다. 따라서 한 예외 처리기에서 특정 예외를 처리하지 않을 경우 처리하기로 결정하기 전까지는 체인의 다음 예외 처리기로 예외 처리기에 전달될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-380">Exception handlers are chained together, so that if one exception handler chooses not to handle a particular exception, it can be passed on to the next exception handler in the chain until one decides to handle it.</span></span> <span data-ttu-id="83fdd-381">처리기 목록은 동적이기 때문에 스택에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-381">Because the list of handler is dynamic, it is stored on the stack.</span></span> <span data-ttu-id="83fdd-382">공격자는 스택 오버플로 취약성을 사용하여 예외 처리기에서 공격자가 선택한 코드에 대한 포인터를 덮어 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-382">An attacker can use a stack overflow vulnerability to then overwrite the exception handler with a pointer to the code of the attacker's choice.</span></span>

<span data-ttu-id="83fdd-383">이 완화는 SEH 디자인에 따라 각 SEH 항목에 예외 처리기에 대한 포인터와 예외 체인의 다음 처리기 포인터가 모두 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-383">This mitigation relies on the design of SEH, where each SEH entry contains both a pointer to the exception handler, as well as a pointer to the next handler in the exception chain.</span></span> <span data-ttu-id="83fdd-384">이 완화는 예외가 호출된 경우 SEH 체인의 유효성을 검사하는 예외 디스패치에 의해 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-384">This mitigation is called by the exception dispatcher, which validates the SEH chain when an exception is invoked.</span></span> <span data-ttu-id="83fdd-385">다음을 검증합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-385">It verifies that:</span></span>

- <span data-ttu-id="83fdd-386">모든 예외 체인 레코드가 스택 경계 내에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-386">All exception chain records are within the stack boundaries</span></span>
- <span data-ttu-id="83fdd-387">모든 예외 레코드가 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-387">All exception records are aligned</span></span>
- <span data-ttu-id="83fdd-388">예외 처리기 포인터가 스택을 포인트하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-388">No exception handler pointers are pointing to the stack</span></span>
- <span data-ttu-id="83fdd-389">뒤로 포인터가 없음</span><span class="sxs-lookup"><span data-stu-id="83fdd-389">There are no backward pointers</span></span>
- <span data-ttu-id="83fdd-390">예외 체인은 알려진 최종 예외 처리기에서 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-390">The exception chain ends at a known final exception handler</span></span>

<span data-ttu-id="83fdd-391">이러한 유효성 검사가 실패하면 예외 처리가 중단됩니다. 예외는 처리되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-391">If these validations fail, then exception handling is aborted, and the exception will not be handled.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-392">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-392">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-393">SEHOP와의 호환성 문제는 비교적 드물게 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-393">Compatibility issues with SEHOP are relatively rare.</span></span> <span data-ttu-id="83fdd-394">응용 프로그램에서 예외 체인 손상에 종속되는 경우는 끊이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-394">It's uncommon for an application to take a dependency on corrupting the exception chain.</span></span> <span data-ttu-id="83fdd-395">그러나 일부 응용 프로그램은 타이밍이 미묘하게 변경되어 응용 프로그램에서 잠정 다중 스레딩 버그를 표시하는 경선 조건으로 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-395">However, some applications are impacted by the subtle changes in timing, which may manifest as a race condition that reveals a latent multi-threading bug in the application.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-396">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-396">Configuration options</span></span>

> [!Note]
> <span data-ttu-id="83fdd-397">**SEHOP(예외 체인)에 감사** 모드가 없는지 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-397">**Validate exception chains (SEHOP)** has no audit mode.</span></span>

## <a name="validate-handle-usage"></a><span data-ttu-id="83fdd-398">핸들 사용 확인</span><span class="sxs-lookup"><span data-stu-id="83fdd-398">Validate handle usage</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-399">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-399">Description</span></span>

<span data-ttu-id="83fdd-400">*핸들 사용 유효성* 검사는 기존 핸들을 사용하여 보호된 개체에 액세스하는 공격자로부터 보호하는 완화입니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-400">*Validate handle usage* is a mitigation that helps protect against an attacker using an existing handle to access a protected object.</span></span> <span data-ttu-id="83fdd-401">[핸들은](/windows/win32/sysinfo/handles-and-objects) 보호된 개체에 대한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-401">A [handle](/windows/win32/sysinfo/handles-and-objects) is a reference to a protected object.</span></span> <span data-ttu-id="83fdd-402">응용 프로그램 코드가 잘못된 핸들을 참조하는 경우 해당 코드가 이전에 기록한 핸들을 사용하려고 시도하고 있지만 인식하지 못하게 될 응용 프로그램 참조 계산을 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-402">If application code is referencing an invalid handle, that could indicate that an adversary is attempting to use a handle it has previously recorded (but which application reference counting wouldn't be aware of).</span></span> <span data-ttu-id="83fdd-403">응용 프로그램에서 단순히 null을 반환하는 대신 잘못된 개체를 사용하려고 하면 응용 프로그램에서 예외를 발생(STATUS_INVALID_HANDLE.</span><span class="sxs-lookup"><span data-stu-id="83fdd-403">If the application attempts to use an invalid object, instead of simply returning null, the application will raise an exception (STATUS_INVALID_HANDLE).</span></span>

<span data-ttu-id="83fdd-404">이 완화는 스토어 응용 프로그램에 Windows 자동으로 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-404">This mitigation is automatically applied to Windows Store applications.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-405">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-405">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-406">핸들 참조를 정확하게 추적하지 못하고 예외 처리기에서 이러한 작업을 래핑하지 않은 응용 프로그램은 잠재적으로 이 완화의 영향을 을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-406">Applications that were not accurately tracking handle references, and which were not wrapping these operations in exception handlers, will potentially be impacted by this mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-407">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-407">Configuration options</span></span>

> [!Note]
> <span data-ttu-id="83fdd-408">**핸들 사용의 유효성 검사에는** 감사 모드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-408">**Validate handle usage** has no audit mode.</span></span>

## <a name="validate-heap-integrity"></a><span data-ttu-id="83fdd-409">힙 무결성 확인</span><span class="sxs-lookup"><span data-stu-id="83fdd-409">Validate heap integrity</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-410">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-410">Description</span></span>

<span data-ttu-id="83fdd-411">유효성 *검사* 힙 무결성 완화는 힙 손상이 감지되면 응용 프로그램이 종료되는 Windows 힙 완화의 보호 수준을 높입니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-411">The *validate heap integrity* mitigation increases the protection level of heap mitigations in Windows, by causing the application to terminate if a heap corruption is detected.</span></span> <span data-ttu-id="83fdd-412">완화에는 다음이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-412">The mitigations include:</span></span>

- <span data-ttu-id="83fdd-413">HEAP 핸들이 비우지 못하게 방지</span><span class="sxs-lookup"><span data-stu-id="83fdd-413">Preventing a HEAP handle from being freed</span></span>
- <span data-ttu-id="83fdd-414">힙 할당을 위해 확장된 블록 헤더에 대해 다른 유효성 검사 수행</span><span class="sxs-lookup"><span data-stu-id="83fdd-414">Performing another validation on extended block headers for heap allocations</span></span>
- <span data-ttu-id="83fdd-415">힙 할당이 아직 사용 중으로 플래그가 지정되지 않은지 확인</span><span class="sxs-lookup"><span data-stu-id="83fdd-415">Verifying that heap allocations are not already flagged as in-use</span></span>
- <span data-ttu-id="83fdd-416">최소 크기 이상의 큰 할당, 힙 세그먼트 및 하위 그룹에 보호 페이지 추가</span><span class="sxs-lookup"><span data-stu-id="83fdd-416">Adding guard pages to large allocations, heap segments, and subsegments above a minimum size</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-417">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-417">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-418">이 완화는 64비트 응용 프로그램 및 Vista 이상을 대상으로 하는 32비트 응용 프로그램에 Windows 이미 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-418">This mitigation is already applied by default for 64-bit applications and for 32-bit applications targeting Windows Vista or later.</span></span> <span data-ttu-id="83fdd-419">XP 또는 Windows 이전 버전의 레거시 응용 프로그램은 거의 사용되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-419">Legacy applications from Windows XP or earlier are most at-risk, though compatibility issues are rare.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-420">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-420">Configuration options</span></span>

> [!Note]
> <span data-ttu-id="83fdd-421">**힙 무결성에 감사** 모드가 없는지 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-421">**Validate heap integrity** has no audit mode.</span></span>

## <a name="validate-image-dependency-integrity"></a><span data-ttu-id="83fdd-422">이미지 종속성 무결성 확인</span><span class="sxs-lookup"><span data-stu-id="83fdd-422">Validate image dependency integrity</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-423">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-423">Description</span></span>

<span data-ttu-id="83fdd-424">이미지 *종속성* 유효성 검사 완화는 이진으로 정적으로 연결된 dll에 대한 코드를 대체하려는 공격으로부터 Windows 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-424">The *validate image dependency* mitigation helps protect against attacks that attempt to substitute code for dlls that are statically linked by Windows binaries.</span></span> <span data-ttu-id="83fdd-425">DLL 심기 기술은 악의적인 코드를 주입하는 로더의 검색 메커니즘을 남용합니다. 악성 코드를 높은 컨텍스트에서 실행하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-425">The technique of DLL planting abuses the loader's search mechanism to inject malicious code, which can be used to get malicious code running in an elevated context.</span></span> <span data-ttu-id="83fdd-426">로더가 Windows 이진 파일을 로드한 다음 이진이 사용하는 모든 dll을 로드하면 이러한 이진 파일도 디지털 서명된 바이너리로 Windows 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-426">When the loader is loading a Windows signed binary, and then loads up any dlls that the binary depends on, these binaries will be verified to ensure that they are also digitally signed as a Windows binary.</span></span> <span data-ttu-id="83fdd-427">서명 검사에 실패하면 dll이 로드되지 않는 것이고 예외가 발생하여 예외가 STATUS_INVALID_IMAGE_HASH.</span><span class="sxs-lookup"><span data-stu-id="83fdd-427">If they fail the signature check, the dll will not be loaded, and will throw an exception, returning a status of STATUS_INVALID_IMAGE_HASH.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-428">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-428">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-429">호환성 문제는 확연한 일입니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-429">Compatibility issues are uncommon.</span></span> <span data-ttu-id="83fdd-430">Windows 이진을 로컬 전용 버전으로 바꾸는 데 의존하는 응용 프로그램에는 영향을 주며 다중 스레드 응용 프로그램에서 미묘한 타이밍 버그가 노출될 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-430">Applications that depend on replacing Windows binaries with local private versions will be impacted, and there is also a small risk of revealing subtle timing bugs in multi-threaded applications.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-431">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-431">Configuration options</span></span>

<span data-ttu-id="83fdd-432">**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-432">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="83fdd-433">그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-433">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="validate-stack-integrity-stackpivot"></a><span data-ttu-id="83fdd-434">스택 무결성 확인(StackPivot)</span><span class="sxs-lookup"><span data-stu-id="83fdd-434">Validate stack integrity (StackPivot)</span></span>

### <a name="description"></a><span data-ttu-id="83fdd-435">설명</span><span class="sxs-lookup"><span data-stu-id="83fdd-435">Description</span></span>

<span data-ttu-id="83fdd-436">스택 무결성 유효성 *검사(StackPivot)* 완화는 공격자가 힙 메모리에 위조 스택을 만든 다음 실행 흐름을 제어하는 위조 스택으로 응용 프로그램을 속이는 ROP 공격인 스택 피벗 공격으로부터 보호하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-436">The *validate stack integrity (StackPivot)* mitigation helps protect against the Stack Pivot attack, a ROP attack where an attacker creates a fake stack in heap memory, and then tricks the application into returning into the fake stack that controls the flow of execution.</span></span>

<span data-ttu-id="83fdd-437">이 완화는 많은 Windows API를 가로채고 스택 포인터 값을 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-437">This mitigation intercepts many Windows APIs, and inspects the value of the stack pointer.</span></span> <span data-ttu-id="83fdd-438">스택 포인터의 주소가 스택의 아래쪽과 위쪽 사이에 있지 않은 경우 이벤트가 기록되고 감사 모드가 아닌 경우 프로세스가 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-438">If the address of the stack pointer does not fall between the bottom and the top of the stack, then an event is recorded and, if not in audit mode, the process will be terminated.</span></span>

<span data-ttu-id="83fdd-439">이 완화로 가로채진 API는 다음입니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-439">The APIs intercepted by this mitigation are:</span></span>

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a><span data-ttu-id="83fdd-440">호환성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="83fdd-440">Compatibility considerations</span></span>

<span data-ttu-id="83fdd-441">가짜 스택을 사용하는 응용 프로그램에는 영향을 주며 다중 스레드 응용 프로그램에서 미묘한 타이밍 버그가 노출될 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-441">Applications that are using fake stacks will be impacted, and there is also a small risk of revealing subtle timing bugs in multi-threaded applications.</span></span>
<span data-ttu-id="83fdd-442">API 가로채기(특히 보안 소프트웨어)를 수행하는 응용 프로그램은 이 완화로 호환성 문제를 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-442">Applications that perform API interception, particularly security software, can cause compatibility problems with this mitigation.</span></span>

<span data-ttu-id="83fdd-443">이 완화는 임의 Code Guard 완화와는 무관합니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-443">This mitigation is incompatible with the Arbitrary Code Guard mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="83fdd-444">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="83fdd-444">Configuration options</span></span>

<span data-ttu-id="83fdd-445">**감사 전용** - 응용 프로그램에 대한 잠재적인 호환성 영향을 측정하기 위해 감사 모드에서 이 완화를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-445">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="83fdd-446">그런 다음 이벤트 뷰어에서 감사 이벤트를 보거나 [끝점용 Microsoft Defender의](/microsoft-365/security/defender/advanced-hunting-overview)고급 헌팅을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83fdd-446">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](/microsoft-365/security/defender/advanced-hunting-overview).</span></span>
